// 函数: sub_4873e4
// 地址: 0x4873e4
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp0 = *arg1
*arg1 += arg1.b
void* const __return_addr_1 = __return_addr
uint16_t* arg_4
int32_t eflags
int16_t entry_ebx

if (temp0 != neg.b(arg1.b))
    *__return_addr_1 += __return_addr_1.b
    *__return_addr_1 += __return_addr_1.b
    *__return_addr_1 += __return_addr_1.b
    *__return_addr_1 += __return_addr_1.b
    *(&arg_4 + (arg5 << 1)) += entry_ebx:1.b
    void arg_4c
    *(&arg_4c + (arg5 << 1)) += (__return_addr_1 - 1).b
    *(__return_addr_1 - 1) += entry_ebx:1.b
    *(__return_addr_1 - 1) += (__return_addr_1 - 1).b
    void* eax
    eax:1.b = (__return_addr_1 - 1):1.b + entry_ebx.b
    void* esi = __outsb(arg2.w, *arg5, arg5, eflags)
    *(eax - 0x43ffbfc3) += arg2:1.b
    void* eax_2
    eax_2.b = eax.b * 2
    void* eax_3
    eax_3:1.b = (eax_2 + 1):1.b + (eax_2 + 1).b
    *(eax_3 + 0x403f) += entry_ebx:1.b
    *(&arg_4 + arg6) += entry_ebx.b
    void* eax_5
    eax_5.b = (eax_3 + 2).b + (eax_3 + 2):1.b
    *esi - *arg6
    void* esi_1 = esi + 1
    int32_t edi = arg6 + 1
    eax_5.b += arg2:1.b
    *esi_1 - *edi
    void* esi_2 = esi_1 + 4
    eax_5.b += entry_ebx:1.b
    *esi_2 - *(edi + 4)
    arg5 = esi_2 + 4
    arg3 = &arg3[3]
    *(arg4 + (arg5 << 1) + 0x75340048) += arg2:1.b
    __return_addr_1 = eax_5 - 1

*arg3 += __return_addr_1.b
entry_ebx.b += entry_ebx:1.b
__return_addr = *(arg5 * 3)
*0x444d4c54 += arg3.b
int32_t* eax_7
uint16_t* esi_4

if (arg5 + 1 s< 0)
    *(__return_addr_1 - 1) += (__return_addr_1 - 1).b
    *(__return_addr_1 - 1) += (__return_addr_1 - 1).b
    *(__return_addr_1 - 1) = *(__return_addr_1 - 1)
    *(__return_addr_1 - 1) += (__return_addr_1 - 1).b
    *(__return_addr_1 - 1) |= (__return_addr_1 - 1).b
    eax_7 = __return_addr_1 + 0x6c676e40
    char* gsbase
    *(gsbase + eax_7) = adc.b(*(gsbase + eax_7), 0x40, __return_addr_1 - 1 u>= 0x939891bf)
    *arg2 += arg2:1.b
    *eax_7 += eax_7.b
    int32_t temp3_1 = *eax_7
    *eax_7 -= 1
    
    if (temp3_1 != 1)
        int16_t es
        uint32_t var_4 = zx.d(es)
        eax_7[0xc].w = 0
        void* esi_3
        esi_3.w = 0xfffc
        return sub_403e64(eax_7, esi_3)
    
    *arg3 += eax_7.b
    *eax_7 += eax_7.b
    *eax_7 += eax_7.b
    *eax_7 += eax_7.b
    *eax_7 += eax_7.b
    *eax_7 += eax_7.b
    *arg3 += arg3.b
    char temp4_1 = *(eax_7 + (arg2 << 1))
    *(eax_7 + (arg2 << 1)) += eax_7.b
    bool c_2 = temp4_1 + eax_7.b u< temp4_1
    esi_4 = __outsd(arg2.w, *(arg5 + 1), arg5 + 1, eflags)
    
    if (not(c_2))
        *(esi_4 - 0x77) = sbb.d(*(esi_4 - 0x77), &__return_addr, c_2)
        arg3:1.b ^= entry_ebx.b
        void* eax_11
        eax_11:1.b = (eax_7 - 1):1.b | *(esi_4 + 0x3b)
        void* eax_12
        eax_12.b = (eax_11 - 1).b ^ 0x74
        esi_4.w = 0xfffc
        return sub_403e64(eax_12 | 0x34488966, esi_4, arg2, arg3)
    
    *eax_7 = adc.b(*eax_7, 0x40, c_2)
    *(eax_7 * 2) += arg2:1.b
else
    void* const __return_addr_2 = __return_addr
    esi_4 = arg_4
    arg4 = arg7
    entry_ebx = arg8
    arg2 = arg9
    arg3 = arg10
    
    if (not(add_overflow(arg5, 1)))
        *(__return_addr_2 + 0x6e)
        *__return_addr_2 += (arg11 - 1).b
        
        if (esi_4 + 1 s< 0)
            jump(0x4874a4)
        
        jump("aption,tH")
    
    eax_7.b = arg11.b

entry_ebx:1.b *= 2
*(arg4 + 0x48) |= arg2:1.b
*arg3 += eax_7.b
*eax_7 += eax_7.b
*arg3 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*arg2 += arg3.b
char temp6 = *(eax_7 + (arg2 << 1))
*(eax_7 + (arg2 << 1)) += eax_7.b
__outsd(arg2.w, *esi_4, esi_4, eflags)

if (temp6 + eax_7.b u< temp6)
    jump(0x4874de)

*(eax_7 + arg3 - 0x7d) <<= arg3.b
undefined
