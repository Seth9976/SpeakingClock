// 函数: sub_418024
// 地址: 0x418024
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
int16_t es
*(arg1 + 0x140041) = es
char temp1 = *arg1
*arg1 += arg1.b
*arg5 = *arg4
void* edi = &arg5[1]
void* esi = &arg4[1]
int32_t entry_ebx

if (temp1 s<= neg.b(arg1.b))
    arg1[0xbc00403e] += arg2:1.b
    void* eax
    eax.b = (&arg1[1]).b * 2
    void* eax_1
    eax_1:1.b = (eax + 1):1.b + (eax + 1).b
    *(eax_1 + 0x403f) += entry_ebx:1.b
    *(&__return_addr + edi) += entry_ebx.b
    int16_t eax_3
    eax_3:1.b = ((eax_1 + 1).w + 1):1.b + entry_ebx.b
    undefined

int32_t* eax_4 = arg1 | 0x6d654d54
int32_t eflags
uint16_t* esi_1 = __outsd(arg2.w, *esi, esi, eflags)
int32_t var_4

if (eax_4 u< 0)
    var_4 = entry_ebx
else
    var_4 = entry_ebx
    
    if (eax_4 != 0)
        void* const __return_addr_1 = __return_addr
        int16_t* edi_2
        int16_t temp0_1
        temp0_1, edi_2 = __insd(var_4, arg8, eflags)
        *edi_2 = temp0_1
        char* eax_7
        void* ecx_2
        int32_t edx_1
        eax_7, ecx_2, edx_1 = sub_41c221(edi_2)
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *(ecx_2 + (eax_7 << 2)) += eax_7.b
        *eax_7 += arg7.b
        *eax_7 += eax_7.b
        *(edi_2 * 3 + 0x3eb00041) += eax_7:1.b
        *(__return_addr_1 + edi_2 + 0x3ec00040) += arg7:1.b
        void* eax_9
        eax_9:1.b = (&eax_7[2]):1.b + (&eax_7[2]).b
        *(eax_9 + 0x403f) += arg7:1.b
        void arg_1c
        *(&arg_1c + edi_2) += arg7.b
        *(arg7 + (edx_1 << 3)) += edx_1:1.b
        *(eax_9 - 0xbffbe36) += (ecx_2 + 2):1.b
        unimplemented  {enter 0x41, 0xc}
        *(eax_9 + 0x640041d1) += (eax_9 + 2).b
        *(ecx_2 + 3) = rol.d(*(ecx_2 + 3), (ecx_2 + 3).b)
        undefined
    
    esi_1 = __outsd(arg2.w, *esi_1, esi_1, eflags)
    
    if (eax_4 != 0)
        eax_4.b &= 4
        jump(*(*eax_4 + 0x24))
    
    int16_t temp0_2
    temp0_2, eflags = __arpl_memw_gpr16(*(arg3 + 0x53), &var_4)
    *(arg3 + 0x53) = temp0_2

if (eax_4 != 0)
    int16_t* edi_4
    int16_t temp0_3
    temp0_3, edi_4 = __insd(var_4, arg8, eflags)
    *edi_4 = temp0_3
    breakpoint

int32_t* var_8 = eax_4
int32_t ecx
int32_t var_c = ecx
int32_t var_10 = arg2
int32_t var_14 = entry_ebx
int32_t* var_18 = &var_14
void* var_1c = arg3
void* var_24 = edi
eax_4.b &= 0x83
eax_4.b &= 4
eax_4.b = __in_al_dx(arg2.w, eflags)
jump(*(*esi_1 + 0x28))
