// 函数: sub_417654
// 地址: 0x417654
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp1 = *arg1
*arg1 += arg1.b
bool c = temp1 + arg1.b u< temp1
bool p = unimplemented  {add byte [eax], al}
bool a = unimplemented  {add byte [eax], al}
bool z = temp1 == neg.b(arg1.b)
bool d
int32_t var_4 = (add_overflow(temp1, arg1.b) ? 1 : 0) << 0xb | (d ? 1 : 0) << 0xa
    | (temp1 + arg1.b s< 0 ? 1 : 0) << 7 | (z ? 1 : 0) << 6 | (a ? 1 : 0) << 4 | (p ? 1 : 0) << 2
    | (c ? 1 : 0)
int32_t* esp = &var_4

if (z || c)
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    arg1.b |= 0x77
    goto label_4176d3

*(arg1 * 2) += arg3.b
*arg1 += arg1.b
arg6[0x40]
arg1[0xbc00403e] += arg2:1.b
void* eax
eax.b = (&arg1[1]).b * 2
void* eax_1
eax_1:1.b = (eax + 1):1.b + (eax + 1).b
void* entry_ebx
*(eax_1 + 0x403f) += entry_ebx:1.b
*(&var_4 + arg6) += entry_ebx.b
*(eax_1 + 0x3e) += entry_ebx.b
arg1 = eax_1 + 3
char temp2_1 = *arg3
*arg3 += arg2.b
bool c_1 = temp2_1 + arg2.b u< temp2_1
char i

do
    void* ecx_2 = arg3 - 1
    int32_t eflags
    arg5 = __outsb(arg2.w, *arg5, arg5, eflags)
    
    if (arg3 != 1 && not(c_1))
        uint8_t temp0_1
        temp0_1, arg6 = __insb(arg6, arg2.w, eflags)
        *arg6 = temp0_1
        esp = *(arg6 + (ecx_2 << 1) + 0x70) * 0x74617265
        *(arg6 + 0x6e)
        arg3 = ecx_2 + 1
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        arg6[arg5 << 1] += arg3.b
    label_4176d3:
        *arg1 += arg2.b
        *arg1 += arg1.b
        char temp3_1 = arg1.b
        arg1.b += entry_ebx.b
        *arg1 = adc.b(*arg1, arg1.b, temp3_1 + entry_ebx.b u< temp3_1)
        arg1.b = 0x3e
        *(arg5 + arg6 + 0x3ec00040) += entry_ebx:1.b
        void* eax_5
        eax_5:1.b = (&arg1[2]):1.b + (&arg1[2]).b
        *(eax_5 + 0x403f) += entry_ebx:1.b
        *(esp + arg6) += entry_ebx.b
        arg1 = eax_5 + 2
        arg6[(entry_ebx << 2) + 0x41] += entry_ebx:1.b
        arg3[1] += entry_ebx.b
        arg1[0xffffffa3] += arg1:1.b
        ecx_2 = &arg3[3]
    
    char temp5_1 = arg1.b
    arg1.b += arg2.b
    bool p_1 = unimplemented  {add al, dl}
    bool a_1 = unimplemented  {add al, dl}
    arg1:1.b = (temp5_1 + arg2.b s< 0 ? 1 : 0) << 7 | (temp5_1 == neg.b(arg2.b) ? 1 : 0) << 6
        | (a_1 ? 1 : 0) << 4 | (p_1 ? 1 : 0) << 2 | (temp5_1 + arg2.b u< temp5_1 ? 1 : 0)
    arg1[0xffffffa0] += (ecx_2 + 1).b
    arg3 = ecx_2 + 2
    i = *0x73694c54
    *0x73694c54 += arg1.b
    c_1 = i + arg1.b u< i
while (i == neg.b(arg1.b))
arg1[0x77] <<= 0x41
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg1[0x77] += arg1:1.b
*(arg1 * 2) += arg1:1.b
*arg1 += arg1.b
arg7 f- fconvert.t(*arg1)
arg1[0xbc00403f] += arg2:1.b
void* eax_8
eax_8.b = (&arg1[2]).b * 2
void* eax_9
eax_9:1.b = (eax_8 + 1):1.b + (eax_8 + 1).b
*(eax_9 + 0x403f) += entry_ebx:1.b
*(esp + arg6) += entry_ebx.b
*(eax_9 + 0xb0041a5) += entry_ebx:1.b
*(esp - 4) = esp
*(esp - 8) = esp - 4
*(esp - 0xc) = 0x64616572
int32_t esi = *(entry_ebx + 0x74) * 0x4177b8
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*(eax_9 + 2) += (eax_9 + 2).b
*0xc004177 += 0x77
char* eax_12
eax_12.b = 0x77 + entry_ebx.b
*eax_12 = adc.b(*eax_12, eax_12.b, 0x77 + entry_ebx.b u< 0x77)
arg6[esi + 0x3ec00040] += entry_ebx:1.b
*0xc00c17f += entry_ebx:1.b
*(esp - 0xd + arg6) += entry_ebx.b
*0x54050041 += (&arg3[1]):1.b
*(entry_ebx + (esi << 1) - 0x75)
*0xc008142 += 0x42
*0xc008142 += 0x42
*0xc008142 += 0x42
*0xc008142 += 0x42
*0xc008142 += 0x42
*0xc008142 += 0x42
char temp8 = *0xc008142
*0xc008142 += entry_ebx:1.b

if (temp8 + entry_ebx:1.b s>= 0)
    jump(0x4177d3)

*(arg2 + 1) -= 0x19
entry_ebx:1.b *= 2
undefined
