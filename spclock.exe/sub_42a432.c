// 函数: sub_42a432
// 地址: 0x42a432
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
int16_t entry_ebx
arg11 += entry_ebx:1.b
arg12 += arg1.b
*arg1 += arg1.b
arg6 f- fconvert.t(*arg1)
arg1[0xbc00403f] += (arg2 + 1):1.b
void* eax_1
eax_1.b = (&arg1[2]).b * 2
void* eax_2
eax_2:1.b = (eax_1 + 1):1.b + (eax_1 + 1).b
*(eax_2 + 0x403f) += entry_ebx:1.b
*(&__return_addr + arg5) += entry_ebx.b
*(arg4 + 0x42) += (arg2 + 1).b
*arg3 += (eax_2 + 2).b
char temp1 = entry_ebx:1.b
char temp2 = entry_ebx:1.b
entry_ebx:1.b *= 2
bool c = temp1 + temp2 u< temp1
int32_t var_4 = *(eax_2 + 0x100042a9)
int32_t* var_8 = &var_4
int32_t var_c = arg2 + 1
int32_t* esp_1 = &var_c
int32_t eflags

if (not(c))
    int16_t temp0_2
    temp0_2, eflags = __arpl_memw_gpr16(*(arg4 + 0x4d), &var_c)
    *(arg4 + 0x4d) = temp0_2
    void arg_14
    esp_1 = &arg_14
    __outsb(arg8, *var_8, var_8, eflags)
label_42a4fe:
    *esp_1
    esp_1[1]
    esp_1[2]
    esp_1[4]
    char* edx_6 = esp_1[5]
    void* i_1 = esp_1[6]
    int16_t eax_11 = (esp_1[7]).w
    esp_1 = &esp_1[8]
    
    if (not(c))
        *(i_1 + 0x31c289d1) = ror.b(*(i_1 + 0x31c289d1), 0xc0)
        void* i
        
        do
            eax_11.b = rol.w(eax_11, 5).b ^ *edx_6
            edx_6 = &edx_6[1]
            i = i_1
            i_1 -= 1
        while (i != 1)
        return eax_11
else
    if (temp1 != neg.b(temp2))
        goto label_42a4fe
    
    int16_t temp0_1
    temp0_1, eflags = __arpl_memw_gpr16(*(arg4 + 0x4d), &var_c)
    *(arg4 + 0x4d) = temp0_1

uint16_t* esi_1 = esp_1[1]
__outsb((esp_1[5]).w, *esi_1, esi_1, eflags)
char* edi = esp_1[8]
char* esi_3 = esp_1[9]
void* ebp_1 = esp_1[0xa]
char* ebx = esp_1[0xc]
int32_t edx_1 = esp_1[0xd]
char* ecx = esp_1[0xe]
void* eax_5 = esp_1[0xf]

if (c)
    ecx.b = sbb.b(ecx.b, *ebx, c)
    
    if (ecx.b == 0)
        return eax_5
    
    esp_1[0xf] = eax_5
    return DeleteObject()

char* eax_6
eax_6:1.b = (eax_5 + 1):1.b * 2
*edi = *esi_3
void* edi_1 = &edi[1]
void* esi_4 = &esi_3[1]
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
*eax_6 += eax_6.b
eax_6:1.b *= 2
*edi_1 = *esi_4
void* edi_2 = edi_1 + 1
void* esi_5 = esi_4 + 1
eax_6:1.b += ecx:1.b
*edi_2 = *esi_5
void* edi_3 = edi_2 + 1
void* esi_6 = esi_5 + 1
*(eax_6 * 2) += eax_6:1.b
*eax_6 += eax_6.b
*(edx_1 + 3 + (eax_6 << 1) + 0x403eb000) ^= eax_6:1.b
*(esi_6 + edi_3 + 0x3ec00040) += ebx:1.b
void* eax_7
eax_7:1.b = (&eax_6[1]):1.b + (&eax_6[1]).b
*(eax_7 + 0x403f) += ebx:1.b
*(&esp_1[0x10] + edi_3) += ebx.b
*(ebp_1 + 0x42) += (edx_1 + 3).b
*ecx += (eax_7 + 2).b
ebx:1.b *= 2
jump(*(eax_7 + 2))
