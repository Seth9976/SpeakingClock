// 函数: sub_424c5c
// 地址: 0x424c5c
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

int32_t edx = arg2 + 1
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
void arg_80042
*(&arg_80042 + (arg3 << 1)) += edx:1.b
*arg1 += arg1.b
arg6 f- fconvert.t(*arg1)
arg1[0xbc00403f] += edx:1.b
void* eax_1
eax_1.b = (&arg1[2]).b * 2
void* eax_2
eax_2:1.b = (eax_1 + 1):1.b + (eax_1 + 1).b
void* entry_ebx
*(eax_2 + 0x403f) += entry_ebx:1.b
*(&__return_addr + arg5) += entry_ebx.b
*(eax_2 - 0x5fffbdb1) += (eax_2 + 2).b
void* eax_5 = (eax_2 + 2) ^ *(eax_2 + 2)
int32_t ecx
int16_t es
ecx, es = __les_gprz_memp(*(arg4 + 0x42))
char temp1 = *(eax_5 + 0xc00424d)
*(eax_5 + 0xc00424d) += edx:1.b
bool c = temp1 + edx:1.b u< temp1
int32_t var_5
void* esp = &var_5:1
bool cond:0 = arg5 == 1

if (c)
    goto label_424d1d

if (not(c))
    *(entry_ebx + 0x74)
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *((ecx << 1) + 0x80042) += entry_ebx.b
    *eax_5 += eax_5.b
    esp = var_5 - 1
    *(eax_5 - 0x43ffbfc2) += (edx + 2):1.b
    void* eax_6
    eax_6.b = (eax_5 + 1).b * 2
    void* eax_7
    eax_7:1.b = (eax_6 + 1):1.b + (eax_6 + 1).b
    *(eax_7 + 0x403f) += entry_ebx:1.b
    *(esp + arg5 - 1) += entry_ebx.b
    *(eax_7 - 0x1bffbdb1) += (eax_7 + 2).b
    eax_5:1.b = (eax_7 + 2):1.b + (eax_7 + 2).b
    arg4 -= 3
    edx += 4
    char temp3_1 = *(eax_5 + 0x600424d)
    *(eax_5 + 0x600424d) += edx:1.b
    cond:0 = temp3_1 == neg.b(edx:1.b)
label_424d1d:
    *(esp - 4) = esp
    *(esp - 8) = entry_ebx
    
    if (cond:0)
        sub_404074(eax_5, edx)
        int32_t edx_5
        edx_5.b = edx.b & 0xfc
        int32_t result = sub_403c58(sub_403c68(*(eax_5 + 4)), edx_5)
        
        if (edx.b s> 0)
            result = sub_40401c(eax_5)
        
        *(esp - 8)
        *(esp - 4)
        return result

int32_t eflags
int16_t temp0
temp0, eflags = __arpl_memw_gpr16(*(entry_ebx - 0x70), arg4.w)
*(entry_ebx - 0x70) = temp0
return sub_424d24(eax_5) __tailcall
