// 函数: sub_42891c
// 地址: 0x42891c
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
TEB* fsbase
*(fsbase + arg2) = arg1
arg1.b = arg1.b
*arg1 += arg1.b
*(arg5 + 0x40)
arg1[0xbc00403e] += arg2:1.b
void* eax
eax.b = (&arg1[1]).b * 2
void* eax_1
eax_1:1.b = (eax + 1):1.b + (eax + 1).b
int16_t entry_ebx
*(eax_1 + 0x403f) += entry_ebx:1.b
*(&__return_addr + arg5) += entry_ebx.b
*(eax_1 + 0x3e) += entry_ebx.b
*arg2 += arg2.b
char* var_4 = arg2
int32_t gsbase
*(gsbase + arg4 + 1 + arg5 + 0x74)
uint16_t* esi = *(gsbase + arg4 + 1 + arg5 + 0x74) * 0x78457972
bool c = unimplemented  {imul esi, dword [gs:bp+di+0x74], 0x78457972}
int32_t eflags
int16_t temp0
temp0, eflags = __arpl_memw_gpr16(*(arg4 + 0x71), &var_4)
*(arg4 + 0x71) = temp0

if (arg4 == 0xffffffff)
    if (c)
        jump(sub_428a50+9)
    
    return sub_4289e0(eax_1 + 3) __tailcall

uint16_t* esi_1 = __outsd(arg2.w, *esi, esi, eflags)
__outsb(arg2.w, *esi_1, esi_1, eflags)
void* ecx
int16_t es
ecx, es = __les_gprz_memp(*(arg3 + 0x42))
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
char* ecx_1
int16_t es_1
ecx_1, es_1 = __les_gprz_memp(*(ecx + 0x42))
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
*(eax_1 + 3) += (eax_1 + 3).b
char temp3 = *(eax_1 + 3)
*(eax_1 + 3) += (eax_1 + 3).b
void* eax_4
eax_4.b = __salc(eflags)
*arg2 = eax_4
eax_4.b = sbb.b(eax_4.b, 0, temp3 + (eax_1 + 3).b u< temp3)
*eax_4 += eax_4.b
arg6 f- fconvert.t(*eax_4)
*(eax_4 - 0x43ffbfc1) += arg2:1.b
void* eax_6
eax_6.b = (eax_4 + 2).b * 2
void* eax_7
eax_7:1.b = (eax_6 + 1):1.b + (eax_6 + 1).b
*(eax_7 + 0x403f) += entry_ebx:1.b
*(&var_4 + arg5) += entry_ebx.b
arg2[(ecx_1 << 2) + 0xe0042] += entry_ebx:1.b
*(eax_7 + 2) += (eax_7 + 2).b
*(eax_7 + 2) += (eax_7 + 2).b
*(eax_7 + 2) += eax_7 + 2
*(eax_7 + 2) += (eax_7 + 2).b
*(eax_7 + 2) += (eax_7 + 2).b
*ecx_1 += ecx_1.b
*0x1000400c = 0x10004010
*0x10004008 = arg2
*(gsbase + arg4 + 1 + arg5 + 0x74)
undefined
