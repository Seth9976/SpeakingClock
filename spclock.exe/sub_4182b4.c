// 函数: sub_4182b4
// 地址: 0x4182b4
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg3 += 8
*arg1 += arg1.b
char temp1 = arg1.b
int32_t entry_ebx
arg1.b += entry_ebx.b
*arg1 = adc.b(*arg1, arg1.b, temp1 + entry_ebx.b u< temp1)
arg1.b = 0x3e
*(arg4 + arg5 + 0x3ec00040) += entry_ebx:1.b
void* eax_1
eax_1:1.b = (&arg1[2]):1.b + (&arg1[2]).b
*(eax_1 + 0x403f) += entry_ebx:1.b
*(&__return_addr + arg5) += entry_ebx.b
char temp2 = *(eax_1 + 0xc004196)
*(eax_1 + 0xc004196) += arg2.b
int32_t eflags
uint8_t* edi
uint8_t temp0
temp0, edi = __insb(arg5, arg2, eflags)
*edi = temp0
void* const* edi_1 = &__return_addr
void* const __return_addr_1 = __return_addr
void* ebx = arg7
void* edx = arg8
int32_t* ecx = arg9
void* arg_18
char* eax_4 = arg_18
char* eax_9
void** esp_1

if (temp2 + arg2.b u>= temp2)
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    eax_9, edx = sub_41c504()
    void arg_24
    esp_1 = &arg_24
else
    void* ebp_1 = *(__return_addr_1 + 0x65) * 0x408d7265
    eax_4[0xffffff83] += ebx.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    eax_4[0xffffff83] += (ecx + 1):1.b
    ecx += 2
    *eax_4 += ecx:1.b
    *eax_4 += eax_4.b
    char temp3_1 = eax_4.b
    eax_4.b += ebx.b
    *eax_4 = adc.b(*eax_4, eax_4.b, temp3_1 + ebx.b u< temp3_1)
    eax_4.b = 0x3e
    *(__return_addr_1 + 1 + edi_1 + 0x3ec00040) += ebx:1.b
    void* eax_6
    eax_6:1.b = (&eax_4[2]):1.b + (&eax_4[2]).b
    *(eax_6 + 0x403f) += ebx:1.b
    void arg_1c
    *(&arg_1c + edi_1) += ebx.b
    void* eax_8
    eax_8:1.b = (eax_6 + 2):1.b + (eax_6 + 2).b
    *ecx = rol.d(*ecx, ecx.b)
    eax_8.b = __in_al_dx(edx.w, eflags)
    *ecx = rol.d(*ecx, ecx.b)
    eax_8.b = *0xa0004033
    *eax_8
    eax_9.b = *0x6004033
    arg_18 = &arg_1c
    esp_1 = &arg_18
    __return_addr_1 += 2
    *(ebp_1 + 0x72)
    *eax_9 += eax_9.b
    *eax_9 += eax_9.b
    *eax_9 += eax_9.b
    *eax_9 += eax_9.b
    eax_9.b += ecx:1.b
    *ecx = *ecx

*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
edx.b += ebx:1.b
int32_t ebp_3
bool c_3

while (true)
    *ecx -= 0x74
    *eax_9 += eax_9.b
    *(ebx + (eax_9 << 2)) += ecx.b
    eax_9[0xbc00403e] += edx:1.b
    void* eax_10
    eax_10.b = (&eax_9[1]).b * 2
    void* eax_11
    eax_11:1.b = (eax_10 + 1):1.b + (eax_10 + 1).b
    *(eax_11 + 0x403f) += ebx:1.b
    *(esp_1 + edi_1) += ebx.b
    *(edx + (ebx << 3) - 0x2c13ffbf) += (ecx + 1):1.b
    *(ebx * 9) += (ecx + 2).b
    *(eax_11 - 0x23) += (ecx + 3).b
    *(eax_11 + 2) += ebx.b
    int16_t top = top - 1
    unimplemented  {fild st0, word [ecx]}
    unimplemented  {fadd qword [ecx]}
    TEB* fsbase
    *(&fsbase->NtTib.StackBase + ecx) += 1
    *(esp_1 - 3) = 0xf00041dc
    unimplemented  {fadd qword [ecx]}
    void* eax_13
    eax_13.b = (eax_11 + 2).b
    *(eax_13 * 2) += ebx.b
    eax_13:1.b += (edx + 2):1.b
    eax_13.b = __in_al_dx((edx + 2).w, eflags)
    *__return_addr_1 += (ecx + 5).b
    *eax_13 += eax_13.b
    *eax_13 += eax_13.b
    *(ecx + 5) += eax_13.b
    *eax_13 += eax_13.b
    *(eax_13 + edx + 2 + 0x800040) += ebx:1.b
    char temp4_1 = *eax_13
    *eax_13 += eax_13.b
    c_3 = temp4_1 + eax_13.b u< temp4_1
    *(esp_1 - 3)
    *(esp_1 - 5) = esp_1 - 1
    *(esp_1 - 9) = edx + 2
    edi_1 = *(esp_1 - 9)
    __return_addr_1 = *(esp_1 - 5)
    ebp_3 = *(esp_1 - 1)
    ebx = *(esp_1 + 7)
    edx = *(esp_1 + 0xb)
    ecx = *(esp_1 + 0xf)
    eax_9 = *(esp_1 + 0x13)
    esp_1 += 0x17
    
    if (not(c_3))
        break
    
    *eax_9 += eax_9.b
    eflags = __cli(eflags)

eax_9[0xffffff84] = rlc.b(eax_9[0xffffff84], 0x41, c_3)
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
eax_9[0xffffff84] += ecx:1.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*eax_9 += eax_9.b
*(edx - 0x7c) += ebx:1.b
*(eax_9 * 2) += edx.b
*(ebx + (eax_9 << 2)) += (ecx + 2).b
eax_9[0xbc00403e] += edx:1.b
void* eax_14
eax_14.b = (&eax_9[1]).b * 2
void* eax_15
eax_15:1.b = (eax_14 + 1):1.b + (eax_14 + 1).b
*(eax_15 + 0x403f) += ebx:1.b
*(esp_1 + edi_1) += ebx.b
*(eax_15 + 2) += (eax_15 + 2).b
*(eax_15 + 0x63c0044) += ebx:1.b
void* eax_19
eax_19.b = (eax_15 + 0xb9c0086).b + ebx:1.b
*(ebp_3 + eax_19 + 0xa380042 + 0xe0042) += ebx.b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += eax_19 + 0xa380042
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
char temp5 = *edi_1
*edi_1 += (eax_19 + 0xa380042).b
bool c_4 = temp5 + (eax_19 + 0xa380042).b u< temp5
*0x2c00400c = 0x2c004010
*0x2c004008 = edi_1

if (not(c_4))
    if (temp5 != neg.b((eax_19 + 0xa380042).b))
        if (c_4)
            jump(0x41840e)
        
        jump(0x418483)
    
    *(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b

*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
*(eax_19 + 0xa380042) += (eax_19 + 0xa380042).b
void* eax_20
eax_20.b = (eax_19 + 0xa380042).b + 0x7b
*(eax_20 * 2) += ebx:1.b
*eax_20 += eax_20.b
unimplemented  {fcom st0, dword [eax]} f- fconvert.t(*eax_20)
*(eax_20 + 0x1400403f) += (edx + 3):1.b
int32_t eflags_1
char temp0_3
temp0_3, eflags_1 = __das((eax_20 + 1).b, eflags)
void* eax_21
eax_21.b = temp0_3
eax_21.b *= 2
void* eax_22
eax_22:1.b = (eax_21 + 1):1.b + (eax_21 + 1).b
*(eax_22 + 0x403f) += ebx:1.b
*(0x2c004008 + edi_1) += ebx.b
*(eax_22 - 0x37ffbdd0) += (eax_22 + 2):1.b
int32_t eflags_2
char temp0_4
temp0_4, eflags_2 = __das((eax_22 + 2).b, eflags_1)
void* eax_24
eax_24.b = temp0_4
*(eax_24 + 0x7004033) += eax_24:1.b
*0x2c004004 = 0x2c004008
*0x2c004000 = 0x2c004004
__builtin_strncpy(0x2c003ffc, "read", 4)
*(ebp_3 + 0xe0a0041)
*0x2c003ff8 = 0x2c003ffc
uint16_t* esi_1 = __outsd((edx + 5).w, *__return_addr_1, __return_addr_1, eflags_2)
int16_t* edi_2
int16_t temp0_5
temp0_5, edi_2 = __insd(edi_1, (edx + 5).w, eflags_2)
*edi_2 = temp0_5

if (add_overflow(ebx, 1))
    int32_t eflags_3
    char temp0_7
    char temp1_1
    temp0_7, temp1_1, eflags_3 = __aam_immb(0x8b, eax_24.b)
    eax_24.b = temp0_7
    eax_24:1.b = temp1_1
    eax_24.b &= 4
    jump(*(*eax_24 + 0x28))

int32_t esi_2 = __outsb((edx + 5).w, *esi_1, esi_1, eflags_2)
uint16_t* gsbase
int32_t esi_3 = __outsb((edx + 5).w, *(gsbase + esi_2), esi_2, eflags_2)

if (ebx != 0xffffffff)
    *0x2c003ffc
    *0x2c004000
    *0x2c004008
    int32_t ecx_11 = *0x2c004010
    int16_t* edi_4
    int16_t temp0_6
    temp0_6, edi_4 = __insd(*0x2c003ff8, (*0x2c00400c).w, eflags_2)
    *edi_4 = temp0_6
    *ecx_11
    undefined

void* ebx_1
ebx_1:1.b = (ebx + 1):1.b * 2
*0x2c003ff4 = eax_24
*0x2c003ff0 = &ecx[1]
*0x2c003fec = edx + 5
*0x2c003fe8 = ebx_1
*0x2c003fe4 = 0x2c003fe8
*0x2c003fe0 = ebp_3
*0x2c003fdc = esi_3
*0x2c003fd8 = edi_2
*(ebx_1 - 0x27fbdbbc) -= eax_24.b
return sub_423b20() __tailcall
