// 函数: sub_438570
// 地址: 0x438570
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

int32_t entry_ebx
*(arg1 - 0x16) += (entry_ebx + 1).b
arg1.b += arg3
int32_t eflags
__out_immb_oeax(0x43, arg1, eflags)
*(&__return_addr + (arg2 << 1)) += arg3
void* const __return_addr_1 = __return_addr
TEB* fsbase
void* ebp = *(fsbase + arg2 + 0x42) * 0x6f747475
__outsb(arg4.w, *__return_addr_1, __return_addr_1, eflags)
int16_t es
*(ebp + 0xc070043) = es
int32_t arg_1c
int32_t* arg_18 = &arg_1c
int32_t edx_1 = arg6
char* arg_2c
char* ecx = arg_2c
char* eax = arg7
char* ebp_1 = *(fsbase + arg4 + 0x42) * 0x6f747475
uint16_t* esi_2 = __outsb(edx_1.w, *arg_18, arg_18, eflags)
*(arg5 + (eax << 1) + 0x43729400) = *(arg5 + (eax << 1) + 0x43729400)
*eax
char temp1 = *(arg5 + 0x74) | edx_1.b
*(arg5 + 0x74) = temp1
void* ebx_1 = arg5 + 1

if (arg5 != 0xffffffff)
    uint8_t* edi_2
    uint8_t temp0
    temp0, edi_2 = __insb(arg4, edx_1.w, eflags)
    *edi_2 = temp0
    
    if (temp1 u>= 0)
        *eax = &eax[*eax]
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
    else
        eax[(ecx << 2) + 0x3c0041] += edx_1:1.b
        edx_1:1.b += ebx_1:1.b
        arg7 = 0x1004569
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        eax[0x4106000d] += eax.b
        int16_t temp0_1
        temp0_1, eflags = __arpl_memw_gpr16(*(ecx + (ebp_1 << 1) + 0x6f), esi_2.w)
        *(ecx + (ebp_1 << 1) + 0x6f) = temp0_1
        esi_2 = __outsb(edx_1.w, *esi_2, esi_2, eflags)
        arg_2c = ebp_1
        void* var_44e8
        ebx_1 = var_44e8
        *eax += eax.b
        eax, edx_1, ecx = (*(ebx_1 + (&arg_2c << 1) + 0x45))()
        *ecx += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        *eax += eax.b
    
    int16_t cs
    arg7 = zx.d(cs)
    *0x67696c41 += eax.b
    int32_t esi_3 = __outsb(edx_1.w, *esi_2, esi_2, eflags)
    __outsd(edx_1.w, *(fsbase + esi_3), esi_3, eflags)
    eax[2] += ebx_1.b
    ebx_1:1.b *= 2
    trap(0xd)

arg7 = 0x69e40045
*eax += eax.b
*eax += eax.b
*ebx_1 = *ebx_1
char temp3 = *eax
*eax += eax.b
bool c = temp3 + eax.b u< temp3
char temp4 = *eax
*eax = adc.b(temp4, eax.b, c)
uint16_t* esi_5 = __outsb(edx_1.w, *esi_2, esi_2, eflags)
int32_t eflags_1
int16_t temp0_2
temp0_2, eflags_1 = __arpl_memw_gpr16(*(eax + 0x6f), (&ebp_1[1]).w)
*(eax + 0x6f) = temp0_2

if (adc.b(temp4, eax.b, c) u>= temp4 && (not(c) || adc.b(temp4, eax.b, c) != temp4))
    int16_t gs
    *(arg4 + 0x41) = gs
    *arg4 += ebx_1.b
    ebx_1:1.b *= 2
    char temp7 = edx_1:1.b
    edx_1:1.b += ebx_1:1.b
    
    if (temp7 + ebx_1:1.b s< 0)
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        *eax
        *eax += eax.b
        *eax
        __builtin_strncpy(&arg7, "ecke", 4)
        undefined
    
    jump(0x438645)

int32_t edi_3
int16_t es_3
edi_3, es_3 = __les_gprz_memp(*(ecx + 0x46))
*eax += eax.b
*eax += eax.b
*0x14ff0000 = *0x14ff0000

if (eax u< 0x909390bd)
    int16_t ds
    arg_2c = zx.d(ds)
    *(&eax[0x6f6c6f43] * 2) += edx_1:1.b
    undefined

eax[0x6f6c6f43] += (&eax[0x6f6c6f43]).b
eax[0x6f6c6f43] = eax[0x6f6c6f43]
char temp6 = eax[0xb2776f58]
eax[0xb2776f58] += (&eax[0x6f6c6f43]).b
bool c_4 = temp6 + (&eax[0x6f6c6f43]).b u< temp6
uint16_t* esi_6 = __outsd(edx_1.w, *esi_5, esi_5, eflags_1)
uint16_t* esi_7 = __outsb(edx_1.w, *esi_6, esi_6, eflags_1)

if (c_4)
    if (c_4)
        jump(sub_43869e+0xa2)
    
    jump(sub_43869e+0x41)

ebx_1:1.b *= 2
*(fsbase + &eax[0x6f6c6f43]) += (&eax[0x6f6c6f43]).b
ecx[1] += 1
eax[0x6f6c6f43] += (&eax[0x6f6c6f43]).b
eax[0x6f6c6f43] += (&eax[0x6f6c6f43]).b
eax[0x6f6c6f43] += (&eax[0x6f6c6f43]).b
eax[0x6f6c6f43] = eax[0x6f6c6f43]
char temp8 = eax[0x6f6c6f43]
eax[0x6f6c6f43] += (&eax[0x6f6c6f43]).b
*(eax + 0x6f6c6f43) =
    sbb.d(*(eax + 0x6f6c6f43), &eax[0x6f6c6f43], temp8 + (&eax[0x6f6c6f43]).b u< temp8)
*(edx_1 + (esi_7 << 1) + 0x61) |= (&eax[0x6f6c6f43]).b
uint16_t* esi_8 = __outsd(edx_1.w, *esi_7, esi_7, eflags_1)
char* gsbase
*(gsbase + &eax[0x6f6c6f43]) += edx_1.b
eax[0x6f6c6f44] += edx_1.b
edx_1:1.b += ebx_1:1.b
arg_2c = 0xd4fe0000
eax[0x6f6c6f44] += (&eax[0x6f6c6f44]).b
eax[0x6f6c6f44] += (&eax[0x6f6c6f44]).b
ecx[1] = ecx[1]
eax[0x6f6c6f44] += (&eax[0x6f6c6f44]).b
__outsb(edx_1.w, *esi_8, esi_8, eflags_1)
__bound_gprv_mema32(arg9, *(arg9 + 0x64))
*arg13 += arg12:1.b
int16_t ebx_3
ebx_3:1.b = arg10:1.b * 2
breakpoint
