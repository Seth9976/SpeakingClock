// 函数: sub_408ac5
// 地址: 0x408ac5
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

arg1.b = *arg1
*arg4
int32_t edi = arg4 + 4
arg1.b = *arg1
arg1.b = *arg1
void* entry_ebx
*(arg3 + 0x100408a) += entry_ebx.b
arg1[1] += (&arg1[1]).b
char temp1 = *(arg2 - 0x74)
*(arg2 - 0x74) += arg2.b
bool c = temp1 + arg2.b u< temp1
char temp2 = *(entry_ebx - 0x71)
*(entry_ebx - 0x71) = adc.b(temp2, entry_ebx:1.b, c)
bool c_1 = adc.b(temp2, entry_ebx:1.b, c) u< temp2 || (c && adc.b(temp2, entry_ebx:1.b, c) == temp2)
void* eax_1 = sbb.d(&arg1[1], 0xdf9c4cdb, c_1)
bool c_2 = unimplemented  {sbb eax, 0xdf9c4cdb}
uint16_t* var_5
void* esp_1 = &var_5:1
void* ecx_1 = arg2 - 0x756affc1
uint16_t* esi_1

if (sbb.d(&arg1[1], 0xdf9c4cdb, c_1) != 0 && ecx_1 != 0)
    *(arg3 + 0x53)
    esi_1 = *(arg3 + 0x53) * 0x68636e79
    bool c_4 = unimplemented  {imul esi, dword [ebp+0x53], 0x68636e79}
    
    if (not(c_4))
        goto label_408b6c
else
    *0x408ac43f = sbb.d(*0x408ac43f, edi, c_2)
    *(eax_1 * 2) += ecx_1:1.b
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    int32_t* esp_2 = &var_5
    void* eax_2 = *eax_1
    
    if (&var_5:1 != 1 && ecx_1 != 1)
        return sub_40eaac(eax_2, arg2, ecx_1 - 1) __tailcall
    
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(eax_2 + 1) += (eax_2 + 1).b
    *(entry_ebx + ((ecx_1 - 1) << 2) + 0x40) += (ecx_1 - 1).b
    *(eax_2 + 1) += arg2:1.b
    *(eax_2 + 1) += (eax_2 + 1).b
    char temp7_1 = (eax_2 + 1):1.b
    char* eax_3
    eax_3:1.b = (eax_2 + 1):1.b + (ecx_1 - 1).b
    *eax_3 = adc.d(*eax_3, eax_3, temp7_1 + (ecx_1 - 1).b u< temp7_1)
    eax_3.b = 0x3e
    void* eax_4
    eax_4.b = (&eax_3[1]).b + arg2.b
    void* eax_5
    eax_5:1.b = (eax_4 + 1):1.b + entry_ebx.b
    void* eax_6
    eax_6:1.b = (eax_5 + 1):1.b + (eax_5 + 1).b
    *(eax_6 - 0x13ffbfc1) += entry_ebx:1.b
    *(&var_5 + edi) += entry_ebx.b
    eax_1 = eax_6 + 3
    *(eax_1 + (arg3 << 3) + 0x54240040) += arg2:1.b
    int32_t eflags
    
    if (arg3 != 1)
    label_408bbd:
        __out_immb_oeax(0x43, eax_1, eflags)
        *eax_1 += eax_1.b
    label_408bc1:
        int32_t result = sub_40451c(eax_1)
        *esp_2
        esp_2[1]
        esp_2[2]
        return result
    
    if (arg3 == 1)
        eax_1 = sub_40cfa8(eax_1, arg2, ecx_1 - 1)
        goto label_408bc1
    
    void* edi_1 = arg2
    esi_1 = var_5
    void* ebp_1 = edi
    arg2 = arg6
    ecx_1 = arg7
    void* arg_13
    eax_1 = arg_13
    void arg_17
    esp_2 = &arg_17
    arg3 = ebp_1 + 1
    
    if (ebp_1 + 1 s< 0)
        goto label_408bbd
    
    uint8_t* edi_2
    uint8_t temp0_1
    temp0_1, edi_2 = __insb(edi_1, arg2.w, eflags)
    *edi_2 = temp0_1
    
    if (ebp_1 != 0xffffffff)
        void* ebx = arg5 - 1
        *(ebx - 0x1374aa40) += ecx_1.b
        esp_2[-4] = ebx
        esp_1 = &esp_2[-4]
    else
        esi_1 = *(esi_1 + 0x65) * 0x74697257
        arg_13 = arg5
        esp_2 = &arg_13
        
        if (ebp_1 + 1 s< 0)
            int16_t temp0_2
            temp0_2, eflags = __arpl_memw_gpr16(*(eax_1 + 0x72), arg3.w)
            *(eax_1 + 0x72) = temp0_2
            esi_1 = __outsd(arg2.w, *esi_1, esi_1, eflags)
        label_408b6c:
            __outsb(arg2.w, *esi_1, esi_1, eflags)
            *(arg2 + 0x65)
            return sub_408b74(ecx_1, arg2, eax_1) __tailcall
        
        eax_1.b = __in_al_dx(arg2.w, eflags)
        esp_2[-4] = arg5
        esp_1 = &esp_2[-4]

*(esp_1 - 4) = esi_1
*(arg3 - 4) = 0
*(esp_1 - 8) = arg3
*(esp_1 - 0xc) = j_sub_40443c
TEB* fsbase
*(esp_1 - 0x10) = fsbase->NtTib.ExceptionList
fsbase->NtTib.ExceptionList = esp_1 - 0x10
*(esp_1 - 0x14) = arg2
sub_4054c8(0, eax_1)
*(esp_1 - 0x18) = sub_4054d8(*(arg3 - 4))
int32_t eax_13
eax_13.b = (CLSIDFromString() & 0x80000000) == 0
char temp6 = eax_13.b
eax_13.b = neg.b(eax_13.b)

if (sbb.d(eax_13, eax_13, temp6 != 0) == 0)
    *(arg3 - 0xc) = eax_1
    *(arg3 - 8) = 0xb
    sub_408ba8(data_4ac3a0, arg3 - 0xc, 0)

*(esp_1 - 8)
fsbase->NtTib.ExceptionList = *(esp_1 - 0x10)
*(esp_1 - 8) = sub_408c4f
sub_405368(arg3 - 4)
return arg3 - 4
