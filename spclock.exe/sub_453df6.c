// 函数: sub_453df6
// 地址: 0x453df6
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

long double result = fconvert.t(*0x3de20045) / arg7
arg1:1.b += arg3:1.b
*(arg4 + 0x3f) += arg1:1.b
*(arg4 + 0x40) += arg3:1.b
*(arg4 + 0x41) += arg2:1.b
*(arg2 - 0x70ffbac3) += arg1.b
arg3[0xb600453d] += arg3:1.b
arg1.b += arg2.b
char temp1 = *arg1
*arg1 += arg1.b
bool c = temp1 + arg1.b u< temp1
void* entry_ebx

if (temp1 + arg1.b s>= 0)
    char temp2_1 = arg3[0xfffffffd]
    arg3[0xfffffffd] += entry_ebx:1.b
    c = temp2_1 + entry_ebx:1.b u< temp2_1

*(arg5 + 0x11d1c281) = sbb.d(*(arg5 + 0x11d1c281), arg1, c)
*arg6 = arg1.b
void* edi = &arg6[1]
char* var_4 = arg1
char* var_8 = arg3
void* var_c = arg2
void* var_10 = entry_ebx
int32_t* var_14 = &var_10
void* var_18 = arg4 + 7
char* var_1c = arg5
void* var_20 = edi
arg1.b *= 2
*0x3df6e870 = arg1
*arg1 += entry_ebx:1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp3 = *arg1
*arg1 += arg1.b
bool p = unimplemented  {add byte [eax], al}
bool a = unimplemented  {add byte [eax], al}
bool d
int32_t var_24 = (add_overflow(temp3, arg1.b) ? 1 : 0) << 0xb | (d ? 1 : 0) << 0xa
    | (temp3 + arg1.b s< 0 ? 1 : 0) << 7 | (temp3 == neg.b(arg1.b) ? 1 : 0) << 6 | (a ? 1 : 0) << 4
    | (p ? 1 : 0) << 2 | (temp3 + arg1.b u< temp3 ? 1 : 0)
*arg5 += arg3:1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char* eax
eax.b = arg1.b + arg3:1.b
*(eax * 2) += entry_ebx:1.b
char temp4 = eax:1.b
eax:1.b += arg3.b
*eax = adc.d(*eax, eax, temp4 + arg3.b u< temp4)
eax.b = 0x3e
void* eax_1
eax_1.b = (&eax[1]).b + arg2.b
void* eax_2
eax_2:1.b = (eax_1 + 1):1.b + entry_ebx.b
void* eax_3
eax_3:1.b = (eax_2 + 1):1.b + (eax_2 + 1).b
*(eax_3 - 0x13ffbfc1) += entry_ebx:1.b
*(&var_24 + edi - 1) += entry_ebx.b
*(eax_3 + 3) += arg2.b
TEB* fsbase
void* eax_8 = (eax_3 + 3) & *arg5 & *(fsbase + arg5)
*(edi + 0x45) -= eax_8.b
eax_8.b += eax_8:1.b
eax_8.b &= 0x46
eax_8.b += arg2:1.b
eax_8.b &= 0x46
*(eax_8 + 0x6800462c) += eax_8:1.b
void* edi_2 = edi
*(arg3 * 3) += entry_ebx.b
*(arg3 * 3 + 0x46) += arg3:1.b
*(arg3 + &arg5[2] + 0x46) += arg3:1.b
eax_8:1.b += arg2:1.b
char* eax_9 = eax_8 ^ *(arg5 + 2)
*eax_9 += eax_9.b
*(entry_ebx + edi_2 + 0x49e00046) += arg2.b
eax_9.b += eax_9:1.b
arg5[6]
*(arg3 + arg4 + 0xb) += arg3:1.b
eax_9[0xc0004621] += arg3:1.b
eax_9.b ^= arg5[8]
void arg_4b
int32_t temp5 = *(&arg_4b + (eax_9 << 1)) | arg2
*(&arg_4b + (eax_9 << 1)) = temp5
int32_t eflags
int16_t temp0
temp0, eflags = __arpl_memw_gpr16(*(entry_ebx + 0x55), (arg4 + 0xb).w)
*(entry_ebx + 0x55) = temp0
void* eax_17
void* ebp_15
void* esi_8

if (temp5 u< 0)
    *eax_9 += eax_9.b
    eax_9.b = arg5[8]
    esi_8 = &arg5[9]
    eax_17 = &eax_9[1]
    ebp_15 = arg4 + 0xc
    *eax_17 += eax_17.b
    *eax_17 += eax_17.b
    *eax_17 += eax_17.b
    *eax_17 += eax_17.b
    *eax_17 += eax_17.b
    *eax_17 += eax_17.b
    *(eax_17 * 3 + 0x2500045) += arg2.b
    goto label_453f6e

char temp0_1
char temp1_1
temp0_1, temp1_1, eflags = __aas((&eax_9[1]).b, (&eax_9[1]):1.b, eflags)
void* eax_11
eax_11.b = temp0_1
eax_11:1.b = temp1_1
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*eax_11 += eax_11.b
*(eax_11 + 0x3f) += eax_11.b
*eax_11 += arg2:1.b
*eax_11 += eax_11.b
char temp6_1 = eax_11.b
eax_11.b += (entry_ebx + 1).b
*eax_11 = adc.b(*eax_11, eax_11.b, temp6_1 + (entry_ebx + 1).b u< temp6_1)
eax_11.b = 0x3e
*(&arg5[8] + edi_2 + 0x3ec00040) += (entry_ebx + 1):1.b
void* eax_13
eax_13:1.b = (eax_11 + 2):1.b + (eax_11 + 2).b
*(eax_13 + 0x403f) += (entry_ebx + 1):1.b
*(&var_24 + edi_2) += (entry_ebx + 1).b
void* eax_15 = eax_13 + 2
*(eax_15 + 0x600464b) += arg2.b
int32_t* var_28 = &var_24
int32_t** esp_1 = &var_28
void* ebp_13 = arg4 + 0xc
esi_8 = __outsd(arg2.w, *(arg5 + 8), &arg5[8], eflags)

if (arg4 == 0xfffffff4)
    char temp0_2
    char temp1_2
    temp0_2, temp1_2, eflags = __aas(&var_28, &var_28, eflags)
    int32_t** eax_16
    eax_16.b = temp0_2
    eax_16:1.b = temp1_2
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *(eax_16 * 3 + 0x45) += arg3:1.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    *eax_16 += eax_16.b
    eax_17 = eax_15 + 1
    ebp_15 = ebp_13 + 2
    *(eax_17 + 2) += arg2.b
label_453f6e:
    *eax_17 += eax_17.b
    int32_t eax_19
    void* ecx
    eax_19, arg2, ecx = 0xc04584a6()
    *arg2
    void* eax_20 = eax_19 ^ *arg2
    int16_t es_1
    edi_2, es_1 = __les_gprz_memp(*esi_8)
    *(esi_8 + (ecx << 3) + 0x45) += (entry_ebx + 1):1.b
    *(eax_20 + 1) += (eax_20 + 1).b
    *(0xfc00403e + edi_2) += (entry_ebx + 1).b
    *(edi_2 + 0x5300045) += (eax_20 + 2).b
    esi_8 += 1
    *(esi_8 + (edi_2 << 2)) += (entry_ebx + 1):1.b
    *edi_2 += ecx.b
    arg3 = ecx + 1
    *(edi_2 + ((entry_ebx + 1) << 2) + 0x45) += arg2:1.b
    *(eax_20 + 2 + (edi_2 << 2) + 0x45) += arg2.b
    *(eax_20 + 2) += (entry_ebx + 1):1.b
    ebp_13 = ebp_15 + 2
    eax_15.b = (eax_20 + 2).b + (entry_ebx + 1).b
    *arg2
    esp_1 = 0xb4004237

int32_t eflags_1
char temp0_4
char temp1_3
temp0_4, temp1_3, eflags_1 = __aaa(eax_15.b, eax_15:1.b, eflags)
eax_15.b = temp0_4
eax_15:1.b = temp1_3
eax_15.b += eax_15:1.b
*(arg2 + 1)
*esi_8 - *edi_2
void* esi_9 = esi_8 + 1
void* edi_3 = edi_2 + 1
*(edi_3 * 9 + 0x45) += (arg2 + 1).b
*(eax_15 + 6) += (eax_15 + 1):1.b
*(esp_1 + eax_15 + 1 + 0x68b80046) += arg3:1.b
void* eax_22
eax_22.b = (eax_15 + 1).b + (arg2 + 1).b
eax_22.b += (arg2 + 1):1.b
*((esi_9 + 1) * 9 + 0x45) += (entry_ebx + 1).b
eax_22.b += (entry_ebx + 1):1.b
eax_22:1.b += (entry_ebx + 1):1.b
arg3[0x45] += eax_22.b
*(eax_22 - 0x5f) += (arg2 + 1):1.b
*eax_22 += (entry_ebx + 1):1.b
*(esp_1 - 4) = 0x45
*(ebp_13 + 7 + ((esi_9 + 1) << 1) + 0x6a340045) += eax_22:1.b
void* ebp_24 = ebp_13 + 8
char temp8 = *eax_22
*eax_22 += (arg2 + 1):1.b

if (temp8 != neg.b((arg2 + 1):1.b) && temp8 + (arg2 + 1):1.b u>= temp8)
    trap(0xd)

char temp9 = *(eax_22 - 0xfffb9f2)
*(eax_22 - 0xfffb9f2) += eax_22.b
int32_t eax_23
void* const esi_11

if (temp9 + eax_22.b s>= 0)
    eax_23 = sx.d(eax_22.w)
    esi_11 = 0xd400045
else
    *(eax_22 + (edi_3 << 1) + 0x45) += arg3:1.b
    *(arg3 * 9 + 0x45) += (entry_ebx + 1).b
    eax_23 = *0xf6b00045
    *(eax_23 - 9) += (arg2 + 1):1.b
    *(arg2 + 1 + ((esi_9 + 1) << 3) + 0x45) += eax_23:1.b
    *(edi_3 + ((esi_9 + 1) << 3) + 0x45) += (arg2 + 1).b
    *(eax_23 + 0x780045a9) += (arg2 + 1):1.b
    arg3.b = 0x45
    *(edi_3 * 5 - 0x467fffbb) += eax_23:1.b
    *(esp_1 - 4 + (edi_3 << 2) + 0x45) += (entry_ebx + 1):1.b
    *(arg2 + 1 + (edi_3 << 2) - 0x3fc3ffbb) += arg3:1.b
    *(eax_23 - 0x40) += eax_23:1.b
    eax_23:1.b += (arg2 + 1):1.b
    *(ebp_24 + 5) = rol.b(*(ebp_24 + 5), 0xf8)
    esi_11 = 0xbe980045
    ebp_24 += 6
    *(eax_23 + 0xd) += eax_23.b

*(eax_23 + (edi_3 << 3) - 0x2ed7ffbb) += (entry_ebx + 1).b
*(esp_1 - 4 + arg3 - 0xaf3ffba) += (arg2 + 1):1.b
*(esi_11 + 1 + arg3) += eax_23.b
*(eax_23 + (edi_3 << 3)) += eax_23.b
*(eax_23 - 0x5fffbfcd) += eax_23:1.b
*eax_23
int32_t eax_24
eax_24.b = *0xa0004033
*eax_24
int32_t eax_25
eax_25.b = *0xa0004033
*eax_25
int32_t eax_26
eax_26.b = *0xa0004033
*eax_26
char* eax_27
eax_27.b = __in_al_dx((arg2 + 1).w, eflags_1)
*(esp_1 - 8) = arg2 + 1
eax_27[0x12004033] += eax_27:1.b
*(esp_1 - 0xc) = esp_1 - 8
void* esp_5 = esp_1 - 0xc

if (entry_ebx != 0xfffffffe)
    *(arg3 * 3 - 0x5f) <<= 0x60
    *arg3 = rol.b(*arg3, 0)
    *0x808b00b4 += (arg2 + 1).b
else if (entry_ebx == 0xfffffffe)
    *(ebp_24 - 0x5eb68b3d) += 1
    *(esp_5 - 4) = eax_27
    *(esp_5 - 8) = arg3
    *(esp_5 - 0xc) = arg2 + 1
    *(esp_5 - 0x10) = entry_ebx + 2
    *(esp_5 - 0x14) = esp_5 - 0x10
    *(esp_5 - 0x18) = ebp_24 + 3
    *(esp_5 - 0x1c) = esi_11 + 3
    *(esp_5 - 0x20) = edi_3
    esp_5 -= 0x20
    *arg3 = rol.b(*arg3, 0)
    *0x808b00b4 += (arg2 + 1).b
else
    int16_t* edi_4
    int16_t temp0_6
    temp0_6, edi_4 = __insd(edi_3, (arg2 + 1).w, eflags_1)
    *edi_4 = temp0_6
    *(entry_ebx + 0x76)
    char* esi_15 = *(entry_ebx + 0x76) * 0x746e6f43
    bool c_5 = unimplemented  {imul esi, dword [ebx+0x74], 0x746e6f43}
    
    if (not(c_5))
        uint8_t* edi_5
        uint8_t temp0_7
        temp0_7, edi_5 = __insb(edi_4, (arg2 + 1).w, eflags_1)
        *edi_5 = temp0_7
        eax_27.b = *esi_15
        uint8_t temp12 = *edi_5
        *edi_5 += (&eax_27[1]).b
        bool c_6 = temp12 + (&eax_27[1]).b u< temp12
        char temp13 = (arg2 + 1).b
        char temp14 = *(entry_ebx + 2 + (&eax_27[1] << 1) + 0x75)
        void* edx
        edx.b = adc.b(temp13, temp14, c_6)
        
        if (adc.b(temp13, temp14, c_6) u>= temp13
                && (not(c_6) || adc.b(temp13, temp14, c_6) != temp13))
            undefined
        
        jump("omListControl")
    
    eax_27.b += 1
    *eax_27 += eax_27.b
    *(esp_5 - 5) = eax_27
    *(esp_5 - 9) = 0xfffffffc
    esp_5 -= 9

*(esp_5 - 4) = *(ebp_24 + 0xb)
SetWindowLongW()
*(esp_5 + 4) = 0xfffffff0
*esp_5 = *(ebp_24 + 0xb)
void* esp_13 = esp_5 + 8

if ((GetWindowLongW() & 0x40000000) != 0)
    *(esp_13 - 4) = 0xfffffff4
    *(esp_13 - 8) = *(ebp_24 + 0xb)
    
    if (GetWindowLongW() == 0)
        *(esp_13 - 4) = *(ebp_24 + 0xb)
        *(esp_13 - 8) = 0xfffffff4
        *(esp_13 - 0xc) = *(ebp_24 + 0xb)
        SetWindowLongW()

*(esp_13 - 4) = data_4ab860
*(esp_13 - 8) = zx.d(data_4b1c56)
*(esp_13 - 0xc) = *(ebp_24 + 0xb)
SetPropA()
*(esp_13 - 4) = data_4ab860
*(esp_13 - 8) = zx.d(data_4b1c54)
*(esp_13 - 0xc) = *(ebp_24 + 0xb)
SetPropA()
*(esp_13 - 4) = *(ebp_24 + 0x17)
*(esp_13 - 8) = *(ebp_24 + 0x13)
*(esp_13 - 0xc) = *(ebp_24 + 0xf)
*(esp_13 - 0x10) = *(ebp_24 + 0xb)
int32_t eax_42 = data_4ab860
data_4ab860 = 0
*(ebp_24 - 1) = (*(eax_42 + 0x1c0))()
*(entry_ebx + 2)
*(esp_13 - 0x10)
*(esp_13 - 0xc)
*(esp_13 - 8)
return result
