// 函数: sub_42a104
// 地址: 0x42a104
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

void* entry_ebx
*(entry_ebx + (arg4 << 3)) += entry_ebx.b
*(arg1 - 0x57) += arg1.b
*((entry_ebx << 3) + 0xebb00042) += (arg2 + 2).b
arg1.b += (arg2 + 3).b
*(arg2 + 3)
int32_t eflags
void* eax
eax.b = __in_al_dx((arg2 + 3).w, eflags)
*(eax - 0x14) += (arg3 + 1).b
char var_20dfffbe[0x20dfffbe]
var_20dfffbe[arg4 << 3] += (arg3 + 1):1.b
*eax += entry_ebx:1.b
char* eax_1 = __in_oeax_dx((arg2 + 6).w, eflags)
*eax_1 += entry_ebx.b
__out_dx_al((arg2 + 7).w, eax_1.b, eflags)
char temp1 = eax_1[0xc0042f1]
eax_1[0xc0042f1] += entry_ebx:1.b

if (temp1 == neg.b(entry_ebx:1.b) || arg3 == 0)
    *(arg2 + 8 + (arg5 << 3) - 0xd57ffbe) += eax_1:1.b
    *eax_1 += eax_1.b
    trap(0xd)

if (temp1 != neg.b(entry_ebx:1.b))
    arg4.w = *arg4 * 0x42a1
    eax_1[0x429e] += entry_ebx:1.b
    char temp2 = *eax_1
    *eax_1 += arg3.b
    
    if (temp2 + arg3.b u< temp2)
        jump(0x42a1f2)
    
    jump("phics")

__sti(__sti(eflags))
eax_1[(arg2 + 0xa) << 1] += arg3.b
int32_t esi = *(arg4 * 3 + 0x61) * 0x616d4970
int32_t eax_2 = entry_ebx + esi
*0x42 = eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
int32_t* esp_2
int16_t es
esp_2, es = __les_gprz_memp(*(arg2 + 0x4d))
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*0x3c0042a2 -= 0x5e
void* eax_3
eax_3.b = 0xa2 + (arg2 + 0xb):1.b
bool d = test_bit(*esp_2, 0xa)
*(eax_3 - 0x4fffbfc2) += (arg2 + 0xc):1.b
eax_3.b *= 2
void* eax_4
eax_4:1.b = (eax_3 + 1):1.b + (eax_3 + 1).b
*(eax_4 + 0x403f) += entry_ebx:1.b
*(&esp_2[1] + arg6) += entry_ebx.b
*(eax_4 - 0xfffbcf8) += (eax_4 + 2).b
*esi - *arg6
char* edi_1

if (d)
    edi_1 = arg6 - 4
else
    edi_1 = arg6 + 4

arg4[entry_ebx * 4 + 0x35e0021].b += (eax_4 + 2).b
*(eax_4 - 0x55) += (eax_4 + 2).b
*(eax_4 + 2 + arg3 + 2 + 0x91c0043) += (entry_ebx + 1).b
void* eax_6
eax_6.b = (eax_4 + 2).b + (arg2 + 0xc).b
*(arg2 + 0xc)
*(entry_ebx + 2) = ror.b(*(entry_ebx + 2), 1)
*(&esp_2[1] + arg3 + 2 + 0xcc40043) += eax_6.b
*eax_6 += eax_6:1.b
*(arg2 + 0xc)
eax_6.b |= 0xe
*(entry_ebx + 5 + arg2 + 0xc + 0x1bc40043) += (entry_ebx + 5):1.b
*(&esp_2[1] + entry_ebx + 6 + 0x43) += (entry_ebx + 6).b
*eax_6 += (arg3 + 2):1.b
eax_6.b += (arg3 + 2):1.b
int16_t ds
*esp_2 = zx.d(ds)
*(edi_1 + entry_ebx + 7) += eax_6.b
*eax_6 += (entry_ebx + 8).b
*(esp_2 - 4) = zx.d(es)
*eax_6 += (arg3 + 2):1.b
*(arg2 + 0xd)
eax_6:1.b = 0xdf
*(eax_6 - 0x7ffbcef) += (entry_ebx + 9):1.b
*(entry_ebx + 9) &= eax_6
eax_6.b ^= 0x11
*eax_6 += eax_6.b
eax_6.b &= *(entry_ebx + 0xa)
eax_6.b = *0x34004322
eax_6.b |= 0x43
*(esp_2 - 4 + arg3 + 2 + 0x1a880043) += (arg2 + 0xe).b
*edi_1 += eax_6.b
*(esp_2 - 8) = esp_2 - 4
*edi_1 += eax_6.b
*(esp_2 - 8)
*(esp_2 - 0xa) = esp_2 - 6
*(arg4 * 3 + 0x61)
*(eax_6 + 0x429e) += ((entry_ebx + 0xa).w + 1):1.b
char temp3 = *eax_6
*eax_6 += (arg3 + 2).b

if (temp3 + (arg3 + 2).b u>= temp3)
    jump("phics")

*(esp_2 - 0xa)
*(esp_2 - 6)
*(esp_2 - 2)
int32_t edx_17 = *(esp_2 + 0xa)
*(esp_2 + 0xe)
char* eax_7 = *(esp_2 + 0x12)
int16_t fs
*(*(esp_2 + 6) + 0x42) = fs
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*(edx_17 + (eax_7 << 1)) += eax_7:1.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
*eax_7 += eax_7.b
eax_7:1.b += edx_17:1.b
*0x340042 = eax_7
*eax_7 += eax_7.b
undefined
