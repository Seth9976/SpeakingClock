// 函数: sub_444f65
// 地址: 0x444f65
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

void* esp_1 = &__return_addr:2
*(arg1 * 2) += arg2
char* eax = (*(arg1 + 0x100447b))()
int32_t eflags
char* eax_4
int32_t* ecx_3
void* edx
uint16_t* esi_4
bool s_3

while (true)
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax = *eax
    eax[0x46090008] += eax.b
    *(arg3 + 0x54)
    arg3 = *(arg3 + 0x54) * 0x73657079
    bool c_1 = unimplemented  {imul ebp, dword [ebp+0x54], 0x73657079}
    *esp_1 = adc.b(*esp_1, esp_1.b, c_1)
    *(eax - 4) = esp_1
    *esp_1 += esp_1.b
    int32_t* eax_2
    void* ecx_1
    eax_2, edx, ecx_1 = (*esp_1)()
    void* esp_4 = eax
    void* entry_ebx
    entry_ebx:1.b *= 2
    *eax_2 += eax_2
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *(eax_2 + 1) += eax_2.b
    *eax_2 |= eax_2
    eax = eax_2 | 0x656c6946
    *(esp_4 - 4) = esp_4
    esp_1 = esp_4 - 4
    void* edi
    
    if ((eax_2 | 0x656c6946) s< 0)
        bool p_1 = unimplemented  {dec ecx}
        arg4 = __outsb(edx.w, *arg4, arg4, eflags)
        
        if (ecx_1 - 1 s>= 0)
            *eax = adc.b(*eax, eax.b, false)
            esp_1 = *esp_1
            *eax += eax.b
        else if (not(p_1))
            *(eax * 2) += entry_ebx.b
        else
            *(ecx_1 - 1) += eax.b
            continue
        
        char* eax_3
        eax_3, edx, ecx_3 = (*(eax * 2))()
        *ecx_3 += 1
        *eax_3 += eax_3.b
        *eax_3 += eax_3.b
        *eax_3 += eax_3.b
        *eax_3 = *eax_3
        char temp9_1 = eax_3[0x4f0d000a]
        eax_3[0x4f0d000a] += eax_3.b
        eax_4 = *(edx + 0x75) * 0x74
        
        if (temp9_1 == neg.b(eax_3.b))
            goto label_445041
        
        __outsb(edx.w, *arg4, arg4, eflags)
        edi = *(esp_1 - 1)
        arg4 = *(esp_1 + 3)
        arg3 = *(esp_1 + 7)
        entry_ebx = *(esp_1 + 0xf)
        edx = *(esp_1 + 0x13)
        ecx_3 = *(esp_1 + 0x17)
        eax_4 = *(esp_1 + 0x1b)
        __bound_gprv_mema32(esp_1 + 0x1f, *(arg3 + 0x6c))
        eax_4.b += 0x41
        *eax_4 += eax_4:1.b
        entry_ebx:1.b *= 2
        *(esp_1 + 0x1c) = eax_4
        *(esp_1 + 0x18) = ecx_3
        *(esp_1 + 0x14) = edx
        *(esp_1 + 0x10) = entry_ebx
        *(esp_1 + 0xc) = esp_1 + 0x10
        *(esp_1 + 8) = arg3
        *(esp_1 + 4) = arg4
        *esp_1 = edi
        *eax_4 += eax_4.b
        *ecx_3 += 1
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 = *eax_4
        char temp11_1 = eax_4[0x4f07000b]
        eax_4[0x4f07000b] += eax_4.b
        
        if (not(add_overflow(temp11_1, eax_4.b)))
            *(edi + 0x6e)
            *(eax_4 * 2) += ecx_3:1.b
            undefined
        
        *eax_4 = *eax_4
        *(eax_4 + 0x1ff0000) += 1
        goto label_445073
    
    eax.b -= 0x71
    ecx_3 = ecx_1 + 1
    *eax += edx:1.b
    entry_ebx:1.b *= 2
    entry_ebx:1.b *= 2
    *eax = &eax[*eax]
    *eax += eax.b
    *eax += eax.b
    eax[0x80000000] += eax.b
    eax_4 = eax | 0x6e4f0900
    void* temp5_1 = arg3
    arg3 += 1
    int32_t gsbase
    bool c_2
    
    if (temp5_1 + 1 s>= 0)
        int16_t temp0_2
        temp0_2, eflags = __arpl_memw_gpr16(*(arg3 + 0x74), arg4.w)
        *(arg3 + 0x74) = temp0_2
        *(gsbase + &ecx_3[0x11])
    label_445041:
        *eax_4 += entry_ebx:1.b
        entry_ebx:1.b *= 2
        entry_ebx:1.b *= 2
        *eax_4 = &eax_4[*eax_4]
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        eax_4[0x80000000] += eax_4.b
        int16_t cs
        *(esp_1 - 4) = zx.d(cs)
        esp_1 -= 4
        *0x69466e4f += ecx_3.b
        uint8_t* edi_1
        uint8_t temp0_3
        temp0_3, edi_1 = __insb(arg5, edx.w, eflags)
        *edi_1 = temp0_3
        edi = edi_1 - 1
        *(entry_ebx + 0x6c)
        eax_4 = *(entry_ebx + 0x6c) * 0x69
        c_2 = unimplemented  {imul eax, dword [ebx+0x6c], 0x69}
        bool o_2 = unimplemented  {imul eax, dword [ebx+0x6c], 0x69}
        int16_t temp0_4
        temp0_4, eflags = __arpl_memw_gpr16(*(entry_ebx + 0x2c), arg3.w)
        *(entry_ebx + 0x2c) = temp0_4
        
        if (not(o_2))
            arg5 = edi - 1
            arg4 = __outsb(edx.w, *arg4, arg4, eflags)
            goto label_4450ac
        
        eax_4[0x80ff0000] += eax_4.b
        *eax_4 += eax_4.b
        *ecx_3 += 1
    label_445073:
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 = *eax_4
        char temp14_1 = eax_4[0x4f0e000f]
        eax_4[0x4f0e000f] += eax_4.b
        uint16_t* esi_2 = __outsb(edx.w, *arg4, arg4, eflags) + 1
        arg4 = __outsd(edx.w, *esi_2, esi_2, eflags)
        uint8_t temp0_5
        temp0_5, arg5 = __insb(edi, edx.w, eflags)
        *arg5 = temp0_5
        
        if (temp14_1 + eax_4.b u< temp14_1)
            goto label_4450cd
        
        *(esp_1 - 4) = 0x65676e61
        esp_1 -= 4
        *(edx + 0x44) &= eax_4.b
        eax_4[0x88ff0000] += ecx_3.b
        *eax_4 += eax_4.b
        *ecx_3 += 1
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 = *eax_4
        char temp17_1 = eax_4[0x4f100010]
        eax_4[0x4f100010] += eax_4.b
        c_2 = temp17_1 + eax_4.b u< temp17_1
        arg4 = __outsb(edx.w, *arg4, arg4, eflags)
        goto label_4450ac
    
    *eax_4 += eax_4.b
    char temp6_1 = eax_4[0x80000000]
    eax_4[0x80000000] += eax_4.b
    bool c_4 = temp6_1 + eax_4.b u< temp6_1
    char temp7_1 = *eax_4
    *eax_4 = adc.b(temp7_1, eax_4.b, c_4)
    bool c_5 =
        adc.b(temp7_1, eax_4.b, c_4) u< temp7_1 || (c_4 && adc.b(temp7_1, eax_4.b, c_4) == temp7_1)
    char temp8_1 = arg5[0x6e]
    arg5[0x6e] = adc.b(temp8_1, ecx_3.b, c_5)
    c_2 =
        adc.b(temp8_1, ecx_3.b, c_5) u< temp8_1 || (c_5 && adc.b(temp8_1, ecx_3.b, c_5) == temp8_1)
label_4450ac:
    bool cond:2_1 = arg4 == 0xffffffff
    esi_4 = __outsd(edx.w, *(arg4 + 1), arg4 + 1, eflags)
    uint8_t temp0_6
    temp0_6, arg5 = __insb(arg5, edx.w, eflags)
    *arg5 = temp0_6
    void* esp_9
    
    if (c_2)
    label_4450f6:
        eax_4[0x4f110012] += eax_4.b
        arg4 = __outsb(edx.w, *esi_4, esi_4, eflags)
        *(esp_1 - 4) = entry_ebx
        esp_9 = esp_1 - 4
    else
        *(esp_1 - 4) = 0x69676e61
        esp_9 = esp_1 - 4
        arg4 = __outsb(edx.w, *esi_4, esi_4, eflags)
        
        if (not(cond:2_1))
            esp_1 = esp_9 + 1
            eax_4[0x90ff0000] += edx.b
            *eax_4 += eax_4.b
            *ecx_3 += 1
            *eax_4 += eax_4.b
            *eax_4 += eax_4.b
            *eax_4 += eax_4.b
        label_4450cd:
            *eax_4 = *eax_4
            char temp15_1 = eax_4[0x4f0b0011]
            eax_4[0x4f0b0011] += eax_4.b
            bool c_6 = temp15_1 + eax_4.b u< temp15_1
            esi_4 = __outsb(edx.w, *arg4, arg4, eflags)
            uint8_t* temp16_1 = arg5
            arg5 -= 1
            bool z_1 = temp16_1 == 1
            s_3 = temp16_1 - 1 s< 0
            
            if (z_1 || c_6)
                entry_ebx:1.b *= 2
                *eax_4 = &eax_4[*eax_4]
            label_445145:
                *eax_4 += eax_4.b
            label_445147:
                *eax_4 += eax_4.b
                char temp18_1 = eax_4[0x80000000]
                eax_4[0x80000000] += eax_4.b
                eax_4.b = adc.b(eax_4.b, 0, temp18_1 + eax_4.b u< temp18_1)
                char temp19_1 = eax_4.b
                eax_4.b |= 0x4f
                s_3 = (temp19_1 | 0x4f) s< 0
                break
            
            if (c_6)
                break
            
            if (c_6)
                goto label_445147
            
            if (z_1)
                goto label_445145
            
            eax_4.b -= 0x71
            ecx_3 += 1
            eax_4[0x98ff0000] += entry_ebx.b
            *eax_4 += eax_4.b
            *ecx_3 += 1
            *eax_4 += eax_4.b
            *eax_4 += eax_4.b
            *eax_4 += eax_4.b
            *eax_4 = *eax_4
            goto label_4450f6
    
    uint8_t temp0_7
    temp0_7, arg5 = __insb(arg5, edx.w, eflags)
    *arg5 = temp0_7
    int16_t temp0_8
    temp0_8, eflags = __arpl_memw_gpr16(*(gsbase + ecx_3 + (arg3 << 1) + 0x6f), arg4.w)
    *(gsbase + ecx_3 + (arg3 << 1) + 0x6f) = temp0_8
    uint16_t* esi_5 = __outsb(edx.w, *arg4, arg4, eflags)
    *(esp_9 - 4) = 0x65676e61
    *(edx + 0x44)
    eax_4[0xa0ff0000] += eax_4:1.b
    *eax_4 += eax_4.b
    *ecx_3 += 1
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 = *eax_4
    eax_4[0x4f100013] += eax_4.b
    uint16_t* esi_6 = __outsb(edx.w, *esi_5, esi_5, eflags)
    *(esp_9 - 8) = entry_ebx + 1
    *(esp_9 - 0xc) = 0x56657261
    esp_1 = esp_9 - 0xc
    *(arg5 + 0x6c)
    esi_4 = __outsb(edx.w, *esi_6, esi_6, eflags)
    eax_4.b -= 0x71
    ecx_3 += 1
    eax_4[0xa8ff0000] += ecx_3:1.b
    *eax_4 += eax_4.b
    *ecx_3 += 1
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 += eax_4.b
    *eax_4 = *eax_4
    char temp13_1 = eax_4[0x4f0c0014]
    eax_4[0x4f0c0014] += eax_4.b
    s_3 = temp13_1 + eax_4.b s< 0
    break

uint8_t* esi_7 = __outsb(edx.w, *esi_4, esi_4, eflags)
*(esp_1 - 4) = esp_1

if (s_3)
    *(esp_1 - 8) = 0x65676e61
    return sub_445160() __tailcall

eax_4.b += ecx_3:1.b
*arg5 = *esi_7
eax_4.b += *eax_4
*(esp_1 - 8) = 0x15
*(esp_1 - 0xc) = 0
*(esp_1 - 0x10) = 0
*(esp_1 - 0x14) = sub_473dc4(eax_4) + divs.dp.d(sx.q(sub_473da8(eax_4) - *(esp_1 + 8) + *esp_1), 3)
int32_t eax_15 = sub_473d90(eax_4)
int32_t eax_19 = sub_473ddc(eax_4) - *(esp_1 + 4) + *(esp_1 - 4)
int32_t eax_20 = eax_19 s>> 1
bool c_8 = unimplemented  {sar eax, 0x1}

if (eax_19 s>> 1 s< 0)
    eax_20 = adc.d(eax_20, 0, c_8)

*(esp_1 - 0x18) = eax_15 + eax_20
*(esp_1 - 0x1c) = 0
*(esp_1 - 0x20) = &esi_7[4]
SetWindowPos()
*(esp_1 + 0xc)
*(esp_1 + 0x10)
*(esp_1 + 0x14)
