// 函数: sub_49e320
// 地址: 0x49e320
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*(arg3 - 1) += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 = *arg1
*arg1 += arg1.b
arg1.b += *arg1
char* eax = arg1 | 0x69736544
bool z = (arg1 | 0x69736544) == 0
int32_t eflags
arg5.w = __outsb(arg2, *arg5, arg5.w, eflags)
char* var_4 = eax
int32_t* esp = &var_4

if (not(z))
    if (not(z))
        int32_t eflags_2
        char temp0_4
        temp0_4, eflags_2 = __arpl_memw_gpr16(*(arg6 + 0x6e), arg4.w)
        *(arg6 + 0x6e) = temp0_4
        undefined
    
    return sub_49e341(eax, arg4, arg6) __tailcall

uint16_t* esi = __outsb(arg2, *arg5, arg5, eflags)
void* entry_ebx

if (arg3 == 2)
    arg4 = *(esi + 0x74) * &data_42a3fc
    eax.b = eax.b
    entry_ebx:1.b *= 2
    esp = 0x10049f5
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax = *eax
    eax[0x49040009] += eax.b
else
    if (true)
        uint8_t* edi_1
        uint8_t temp0_1
        temp0_1, edi_1 = __insb(var_4, arg8, eflags)
        *edi_1 = temp0_1
        *arg10 += arg8.b
        void* eax_3 = &arg10[1]
        *eax_3 += arg8:1.b
        *eax_3 += eax_3.b
        arg10 = *eax_3
        *eax_3 += eax_3.b
        *arg9 += 1
        *eax_3 += eax_3.b
        *eax_3 += eax_3.b
        *eax_3 += eax_3.b
        *arg9 = *arg9
        *eax_3 += eax_3.b
        int16_t es
        arg9 = zx.d(es)
        *edi_1 += eax_3.b
        __outsb(arg8, *__return_addr, __return_addr, eflags)
        __bound_gprv_mema32(arg11, *(arg11 + 0x64))
        *arg15 += arg15.b
        undefined
    
    *eax += eax.b
    eax[0x80000000] += eax.b
    *eax |= eax
    eax.b += 0x49

int32_t eflags_1
char temp0_2
temp0_2, eflags_1 = __arpl_memw_gpr16(*(arg6 + 0x6e), arg4.w)
*(arg6 + 0x6e) = temp0_2
*eax += arg2.b
*(&eax[1] * 2) += entry_ebx:1.b
entry_ebx:1.b *= 2
void* eax_5
eax_5.b = __in_al_dx(arg2, eflags_1)
*(arg3 - 3) += eax_5.b
*eax_5 += eax_5.b
*eax_5 += eax_5.b
*eax_5 += eax_5.b
*eax_5 = *eax_5
*eax_5 += eax_5.b
eax_5.b |= *eax_5
*(arg3 + 0x60)
uint16_t* esi_4 = __outsd(arg2, *esi, esi, eflags_1)
*(esp - 4) = __outsb(arg2, *esi_4, esi_4, eflags_1)
*(entry_ebx + 0x69)
*(entry_ebx + 0x69)
bool c_1 = unimplemented  {imul esi, dword [ebx+0x69], 0x54656c62}
*eax_5 = adc.b(*eax_5, eax_5.b, c_1)
*eax_5
entry_ebx:1.b *= 2
breakpoint
