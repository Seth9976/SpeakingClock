// 函数: sub_429834
// 地址: 0x429834
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
int32_t entry_ebx
arg1[0x98ac0042] = entry_ebx.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*(arg2 - 0x5dffbd67) += entry_ebx.b
int32_t eax = sx.d(arg1.w)
*(eax * 2) += eax:1.b
*eax += eax.b
void* const __return_addr_1 = __return_addr
int32_t edi = eax
char* eax_1 = arg5
void* edx_2 = arg2 + 3
char* ecx

while (true)
    eax_1[0xbc00403e] += edx_2:1.b
    void* eax_2
    eax_2.b = (&eax_1[1]).b * 2
    void* eax_3
    eax_3:1.b = (eax_2 + 1):1.b + (eax_2 + 1).b
    *(eax_3 + 0x403f) += entry_ebx:1.b
    *(__return_addr_1 + edi) += entry_ebx.b
    *(eax_3 + 2) += edx_2:1.b
    ecx.b = 0x42
    void* eax_5
    eax_5.b = (eax_3 + 2).b + edx_2:1.b
    *arg4 - *edi
    void* esi = &arg4[4]
    void* edi_1 = edi + 4
    eax_5.b += entry_ebx:1.b
    *esi - *edi_1
    arg4 = esi + 4
    char* edi_2 = edi_1 + 4
    ecx[(arg4 << 2) + 0x44] += edx_2:1.b
    *arg4 += (&ecx[2]).b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    ecx[2] += eax_5.b
    *eax_5 += eax_5.b
    eax_5.b += entry_ebx:1.b
    edi = eax_5
    *edi_2 += edi_2:1.b
    *edi_2 += edi_2.b
    ecx[2] += edi_2.b
    char* ecx_2
    ecx_2:1.b = (&ecx[2]):1.b + entry_ebx:1.b
    void* edx_4
    eax_1, edx_4, ecx = (*(edi_2 - 0x4f))()
    edx_2 = edx_4 + 1
    char temp1_1 = *0x6e6f4654
    *0x6e6f4654 += eax_1.b
    
    if (temp1_1 != neg.b(eax_1.b))
        break
    
    *eax_1 += eax_1.b
    *(edi + (edx_2 << 2) + 0x42) += entry_ebx.b

int32_t eax_7 = sx.d(eax_1.w)
*edi += eax_7.b
int32_t eax_8 = eax_7 + 0x6e6f4654
int32_t eflags
void* edx_10
uint16_t* esi_2
uint8_t* edi_4

if (eax_7 == 0x9190b9ac)
    ecx:1.b = 0x42
label_429932:
    *(eax_8 + 0x10042b5) += eax_8:1.b
label_429938:
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 = *eax_8
    char temp5_1 = *(eax_8 + 0x4e040003)
    *(eax_8 + 0x4e040003) += eax_8.b
    esi_2 = *(__return_addr_1 + 4)
    arg3 = *(__return_addr_1 + 8)
    *(__return_addr_1 + 0x10)
    edx_10 = *(__return_addr_1 + 0x14)
    ecx = *(__return_addr_1 + 0x18)
    char* eax_10 = *(__return_addr_1 + 0x1c)
    int32_t temp0_5
    temp0_5, edi_4 = __insd(*__return_addr_1, edx_10.w, eflags)
    *edi_4 = temp0_5
    *(__return_addr_1 + 0x1c) = __return_addr_1 + 0x20
    *eax_10 = adc.b(*eax_10, eax_10.b, temp5_1 + eax_8.b u< temp5_1)
    eax_10.b = __in_al_dx(edx_10.w, eflags)
    edx_10:1.b = 0x42
    eax_10:1.b += 0x42
    edx_10:1.b = 0x42
    *ecx += eax_10.b
    *eax_10 += eax_10.b
    *eax_10 += eax_10.b
    *eax_10 += eax_10.b
    *eax_10 = *eax_10
    *eax_10 += eax_10.b
    eax_10.b = eax_10.b
else
    int32_t eax_9
    eax_9:1.b = sx.d(eax_8.w):1.b + ecx.b
    eax_8 = edi
    *eax_8 += ecx.b
    char temp3_1 = *eax_8
    *eax_8 += ecx.b
    bool c_1 = temp3_1 + ecx.b u< temp3_1
    edi_4 = eax_9 + 1
    
    if (c_1)
        eax_8.b += *eax_8
        int16_t es
        *(__return_addr_1 - 4) = zx.d(es)
        eax_8 -= 1
    label_429926:
        int32_t gsbase
        __return_addr_1 = *(gsbase + edi_4 + 0x68) * 0x42951074
        *(eax_8 - 0x5fffbd4b) += ecx.b
        ecx:1.b = 0x42
        *ecx += eax_8.b
        goto label_429938
    
    if (add_overflow(eax_9, 1))
        *(arg3 - 0x4a77ffbe) = adc.b(*(arg3 - 0x4a77ffbe), (edx_2 + 3).b, c_1)
        goto label_429932
    
    int32_t esp_1 = *(entry_ebx + 0x73) * 0x95200008
    *(arg4 * 5 - 0x4943ffbe) += (edx_2 + 4):1.b
    *ecx += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    char i
    
    do
        *eax_8 = *eax_8
        i = *(eax_8 + 0x43070000)
        *(eax_8 + 0x43070000) += eax_8.b
        *(esp_1 - 4) = 0x65737261
        esp_1 -= 4
    while (i == neg.b(eax_8.b))
    char ebx = eax_8.b
    eax_8 = entry_ebx
    edx_10 = edx_2 + 6
    *eax_8 += ebx
    *eax_8 += eax_8.b
    *(esp_1 - 4) = *(eax_8 + 0x10042b2)
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 = *eax_8
    char temp7_1 = *(eax_8 + 0x43050001)
    *(eax_8 + 0x43050001) += eax_8.b
    bool c_2 = temp7_1 + eax_8.b u< temp7_1
    uint16_t* esi_1 = __outsd(edx_10.w, *arg4, arg4, eflags)
    uint8_t temp0_4
    temp0_4, edi_4 = __insb(edi_4, edx_10.w, eflags)
    *edi_4 = temp0_4
    esi_2 = __outsd(edx_10.w, *esi_1, esi_1, eflags)
    
    if (not(c_2))
        *eax_8 = adc.b(*eax_8, eax_8.b, c_2)
        *(esp_1 - 8) = eax_8
        ecx:1.b = 0x42
        *(eax_8 - 0x4b) += ebx
        *ecx += eax_8.b
        *eax_8 += eax_8.b
        *eax_8 += eax_8.b
        *eax_8 += eax_8.b
        *eax_8 = *eax_8
        *(eax_8 + 0x48060002) += eax_8.b
        goto label_429926
    
    *eax_8 += eax_8.b
    *(eax_8 * 2) += eax_8.b

*(edi_4 + 0x72)
*(arg3 + 0x6e)
uint16_t* esi_3 = __outsd(edx_10.w, *esi_2, esi_2, eflags)
__outsb(edx_10.w, *esi_3, esi_3, eflags)
breakpoint
