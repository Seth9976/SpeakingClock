// 函数: sub_47ff53
// 地址: 0x47ff53
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

int32_t eflags_1
int16_t temp0_3
temp0_3, eflags_1 = __arpl_memw_gpr16(*arg1, arg3.w)
*arg1 = temp0_3
*arg1 += arg1
*arg1 += arg1.b
*arg1 += arg1.b
*(arg1 + 1) += arg1.b
char* eax = arg1 | 0x6c410b00
int32_t esp_1 = *(arg6 + 0x6e) * 0x74747542
uint16_t* esi = __outsd(arg2.w, *arg5, arg5, eflags_1)
uint16_t* esi_1 = __outsb(arg2.w, *esi, esi, eflags_1)
*(esp_1 - 4) = 0x6100451d
*eax += eax.b
void* eax_1 = eax - 1
*(esp_1 - 8) = 0x69e40045
uint16_t* ebp = arg4 + 1
*eax_1 += eax_1.b
*eax_1 += eax_1.b
char* entry_ebx
*entry_ebx = *entry_ebx
*eax_1 += eax_1.b
int16_t cs
*(esp_1 - 0xc) = zx.d(cs)
char temp1 = *arg6
*arg6 += eax_1.b
char* ecx = arg3 + 1
uint16_t* esi_2 = __outsb(arg2.w, *esi_1, esi_1, eflags_1)
int32_t eflags
int16_t temp0
temp0, eflags = __arpl_memw_gpr16(*(eax_1 + 0x6f), ebp.w)
*(eax_1 + 0x6f) = temp0
uint16_t* eax_5
void* ecx_1
void* esp_6
bool c_6
bool s_2
void* eax_2
void** esp_10
bool c_5

if (temp1 + eax_1.b u< temp1)
    *eax_1 += eax_1.b
    *(esp_1 - 0x10) = esp_1 - 0xc
    esp_10 = esp_1 - 0x10
label_48000b:
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 = *eax_1
    *(eax_1 + 0x48040008) += eax_1.b
    ebp = *(esi_2 + 0x74) * &data_40103c
    eax_2 = *esp_10
    esp_6 = &esp_10[1]
    eax_2.b += *eax_2
label_480022:
    *(ecx + 0x10048) += 1
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    char temp6_1 = *eax_2
    *eax_2 += eax_2.b
    c_5 = temp6_1 + eax_2.b u< temp6_1
label_480033:
    eax_2.b = adc.b(eax_2.b, *eax_2, c_5)
    ecx = &ecx[*(ebp + 0x69)]
    esi_2 = __outsb(arg2.w, *esi_2, esi_2, eflags)
    arg2[1].b += entry_ebx.b
    entry_ebx:1.b *= 2
    char temp0_2
    char temp1_1
    temp0_2, temp1_1, eflags = __aam_immb(0x61, (eax_2 + 1).b)
    void* eax_4
    eax_4.b = temp0_2
    eax_4:1.b = temp1_1
    eax_2 = eax_4 - 1
label_480044:
    *ecx += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *(eax_2 * 2)
    *(eax_2 * 2) = 0
    eax_5 = adc.d(eax_2, *eax_2, false)
    int32_t temp11_1 = *(ebp + 0x61)
    ecx_1 = &ecx[*(ebp + 0x61)]
    c_6 = &ecx[temp11_1] u< ecx
    s_2 = &ecx[temp11_1] s< 0
else
    *0x2540045 <<= 1
    char temp2_1 = entry_ebx:1.b
    char temp3_1 = entry_ebx:1.b
    entry_ebx:1.b *= 2
    bool p_1 = unimplemented  {add bh, bh}
    bool a_1 = unimplemented  {add bh, bh}
    bool d
    *(esp_1 - 0x10) = (add_overflow(temp2_1, temp3_1) ? 1 : 0) << 0xb | (d ? 1 : 0) << 0xa
        | (temp2_1 + temp3_1 s< 0 ? 1 : 0) << 7 | (temp2_1 == neg.b(temp3_1) ? 1 : 0) << 6
        | (a_1 ? 1 : 0) << 4 | (p_1 ? 1 : 0) << 2 | (temp2_1 + temp3_1 u< temp2_1 ? 1 : 0)
    esi_2 = *(esp_1 - 0x10)
    esp_6 = esp_1 - 0xc
    eax_2 = eax_1 - 1
    *ecx += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 = *eax_2
    char temp4_1 = *(eax_2 + 0x4109000f)
    *(eax_2 + 0x4109000f) += eax_2.b
    
    if (temp4_1 + eax_2.b u>= temp4_1)
        goto label_480023
    
    esi_2 = __outsd(arg2.w, *esi_2, esi_2, eflags)
    int16_t temp0_1
    temp0_1, eflags = __arpl_memw_gpr16(*(ecx + 0x61), ebp.w)
    *(ecx + 0x61) = temp0_1
    
    if (temp4_1 == neg.b(eax_2.b))
        eax_2 += 1
        *(eax_2 + 2) += entry_ebx.b
        entry_ebx:1.b *= 2
    label_480023:
        ecx[0x48]
        *ecx += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 = *eax_2
        char temp5_1 = *eax_2
        *eax_2 += eax_2.b
        c_5 = temp5_1 + eax_2.b u< temp5_1
        goto label_480033
    
    *eax_2 += arg2.b
    eax_2 += 1
    *(eax_2 + 2) += arg2.b
    entry_ebx:1.b *= 2
    *(eax_2 + (ecx << 1)) |= eax_2:1.b
    *eax_2 += eax_2
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    char temp7_1 = *(eax_2 + 1)
    *(eax_2 + 1) += eax_2.b
    *eax_2 = adc.b(*eax_2, eax_2.b, temp7_1 + eax_2.b u< temp7_1)
    int32_t temp8_1 = *(ecx + 0x72) | eax_2
    *(ecx + 0x72) = temp8_1
    
    if (temp8_1 u< 0)
        goto label_480044
    
    if (temp8_1 u> 0)
        goto label_480022
    
    if (temp8_1 s< 0)
        *eax_2 += arg2.b
        *(eax_2 + 1) += arg2.b
        arg2:1.b += entry_ebx:1.b
        *(esp_6 - 4) = 0xd4fe0000
        *(eax_2 + 1) += (eax_2 + 1).b
        *(eax_2 + 1) += (eax_2 + 1).b
        *ecx = *ecx
        char temp16_1 = *(eax_2 + 1)
        *(eax_2 + 1) += (eax_2 + 1).b
        *(eax_2 + 1) = adc.d(*(eax_2 + 1), eax_2 + 1, temp16_1 + (eax_2 + 1).b u< temp16_1)
        *(esp_6 - 4)
        __outsb(arg2.w, *esi_2, esi_2, eflags)
        arg6 = *(esp_6 - 2)
        esi_2 = *(esp_6 + 2)
        void* ebp_1 = *(esp_6 + 6)
        entry_ebx = *(esp_6 + 0xe)
        arg2 = *(esp_6 + 0x12)
        ecx = *(esp_6 + 0x16)
        eax_1 = *(esp_6 + 0x1a)
        __bound_gprv_mema32(ebp_1, *(ebp_1 + 0x64))
        esp_10 = 0x84004010
        *eax_1 += eax_1.b
        *(eax_1 * 2 - 0x610b0100) += 1
        goto label_48000b
    
    TEB* fsbase
    *(fsbase + eax_2) += eax_2.b
    *entry_ebx += arg2.b
    char temp14_1 = *entry_ebx
    *entry_ebx += eax_2.b
    c_6 = temp14_1 + eax_2.b u< temp14_1
    s_2 = ebp - 1 s< 0
    arg6 = *esp_6
    esi_2 = *(esp_6 + 4)
    ebp = *(esp_6 + 8)
    entry_ebx = *(esp_6 + 0x10)
    arg2 = *(esp_6 + 0x14)
    ecx_1 = *(esp_6 + 0x18)
    eax_5 = *(esp_6 + 0x1c)
    esp_6 += 0x20

if (not(s_2))
    *eax_5 = adc.b(*eax_5, eax_5.b, c_6)
    *esp_6
    eax_5.b += *eax_5
    jump(*arg2)

*ecx_1 += eax_5.b
*eax_5 += eax_5.b
*eax_5 += eax_5.b
*eax_5 += eax_5.b
*ecx_1 = *ecx_1
*eax_5 += eax_5.b
int16_t ss
*(esp_6 - 4) = zx.d(ss)
void* esp_13 = esp_6 - 4
char temp12 = *entry_ebx
*entry_ebx += ecx_1.b

if (temp12 + ecx_1.b u< temp12)
    *eax_5 += eax_5.b
label_48012a:
    char temp17_1 = *eax_5
    *eax_5 += eax_5.b
    *eax_5 = sbb.d(*eax_5, eax_5, temp17_1 + eax_5.b u< temp17_1)
else
    uint16_t* gsbase
    esi_2 = __outsb(arg2.w, *(gsbase + esi_2), esi_2, eflags)
    
    if (arg6 == 1)
        *eax_5 += eax_5.b
        char temp18_1 = *eax_5
        *eax_5 += eax_5.b
        *eax_5 = sbb.d(*eax_5, eax_5, temp18_1 + eax_5.b u< temp18_1)
    else if (arg6 != 1)
        uint16_t* esi_4 = __outsd(arg2.w, *esi_2, esi_2, eflags)
        esi_2 = __outsb(arg2.w, *esi_4, esi_4, eflags)
        *eax_5 += arg2.b
        eax_5 += 1
        esi_2[0x267f8000].b += ecx_1.b
        
        if (esi_2[0x267f8000].b + ecx_1.b s>= 0)
            *(ecx_1 + 0x48) += ecx_1.b
            eax_5[0x802431].b += eax_5.b
            *eax_5 += eax_5.b
            *eax_5 += eax_5.b
            *eax_5 += eax_5.b
            *eax_5 = *eax_5
            goto label_48012a
        
        *ecx_1 += eax_5.b
        *eax_5 += eax_5.b
        *eax_5 += eax_5.b
        *eax_5 += eax_5.b
        *ecx_1 = *ecx_1
        *eax_5 += eax_5.b
        *esp_13
        char temp21_1 = *esi_2
        *esi_2 += ecx_1.b
        *(esp_13 - 2) = eax_5
        int32_t edi_1 = *(esp_13 - 2)
        uint16_t* esi_5 = *(esp_13 + 2)
        int32_t ebp_2 = *(esp_13 + 6)
        *(esp_13 + 0xe)
        arg2 = *(esp_13 + 0x12)
        int32_t ecx_2 = *(esp_13 + 0x16)
        char* eax_6 = *(esp_13 + 0x1a)
        
        if (temp21_1 + ecx_1.b u>= temp21_1)
            int32_t esi_6 = __outsb(arg2.w, *esi_5, esi_5, eflags)
            
            if (temp21_1 == neg.b(ecx_1.b))
                jump(0x48013c)
            
            return sub_4800e9(eax_6, arg2, ecx_2, ebp_2, esi_6, edi_1) __tailcall
        
        *eax_6 += eax_6.b
        char temp27 = eax_6[0x5308001a]
        eax_6[0x5308001a] += eax_6.b
        *(esp_13 + 0x1a) = 0x6948776f
        __outsb(arg2.w, *esi_5, esi_5, eflags)
        
        if (temp27 == neg.b(eax_6.b))
            jump(0x480153)
        
        jump(0x48015b)

char temp19_1 = *(eax_5 + 0x6f)
*(eax_5 + 0x6f) |= arg2.b

if ((temp19_1 | arg2.b) == 0)
    eax_5.b += *eax_5
    *ecx_1 += 1
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 += eax_5.b
    *eax_5 = *eax_5
    eax_5[0x27850010].b += eax_5.b
    uint16_t* esi_13 = __outsb(arg2.w, *esi_2, esi_2, eflags)
    *(esp_13 - 4) = 0x69676e61
    __outsb(arg2.w, *esi_13, esi_13, eflags)
    trap(0xd)

*eax_5 = adc.b(*eax_5, eax_5.b, false)
eax_5.b += *eax_5
*(esp_13 + 0x48) += 1
*ecx_1 += eax_5.b
*eax_5 += eax_5.b
*eax_5 += eax_5.b
*eax_5 += eax_5.b
*ecx_1 = *ecx_1
char temp23 = *eax_5
*eax_5 += eax_5.b
bool c_11 = temp23 + eax_5.b u< temp23
char* eax_8 = sbb.d(eax_5, 0x68540900, c_11)
bool c_12 = unimplemented  {sbb eax, 0x68540900}
uint16_t* esi_10 = __outsd(arg2.w, *esi_2, esi_2, eflags)

if (sbb.d(eax_5, 0x68540900, c_11) == 0)
    int32_t edi_2 = *esp_13
    uint16_t* esi_11 = *(esp_13 + 4)
    *(esp_13 + 8)
    *(esp_13 + 0x10)
    *(esp_13 + 0x18)
    char* eax_9 = *(esp_13 + 0x1c)
    __outsb((*(esp_13 + 0x14)).w, *esi_11, esi_11, eflags)
    *eax_9 = adc.b(*eax_9, eax_9.b, c_12)
    *(esp_13 + 0x1c) = edi_2
    *eax_9 += eax_9.b
    undefined

eax_8.b += *eax_8
*ecx_1 += 1
*eax_8 += eax_8.b
*eax_8 += eax_8.b
*eax_8 += eax_8.b
*eax_8 = *eax_8
eax_8[0x4f0c0021] += eax_8.b
uint16_t* esi_15 = __outsb(arg2.w, *esi_10, esi_10, eflags)
*(esp_13 - 4) = 0x69676e61
uint16_t* esi_17 = __outsb(arg2.w, *esi_15, esi_15, eflags)

if (ebp + 1 s< 0)
    __outsb(arg2.w, *esi_17, esi_17, eflags)
    *(ebp + 0x68)
    *eax_8 += eax_8:1.b
    *eax_8 = &eax_8[*eax_8]
    jump(*eax_8)

*(ebp + 1) -= eax_8.b
*ecx_1 &= eax_8.b
void* ebx_3
ebx_3:1.b = (&entry_ebx[1]):1.b * 2
*ecx_1 &= eax_8.b
ebx_3:1.b *= 2
*eax_8 = &eax_8[*eax_8]
*eax_8 += eax_8.b
*eax_8 += eax_8.b
eax_8[0x80000000] += eax_8.b
eax_8.b &= *eax_8
*(esp_13 - 8) = zx.d(cs)
uint16_t* esi_18 = __outsb(arg2.w, *esi_17, esi_17, eflags)
uint16_t* esi_19 = __outsd(arg2.w, *esi_18, esi_18, eflags)
__outsb(arg2.w, *esi_19, esi_19, eflags)

if (ebx_3 == 0xffffffff)
    jump(0x4802d7)

jump("xtPopup")
