// 函数: sub_46a8de
// 地址: 0x46a8de
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg4
char* eax = arg1 + *arg1
*eax += eax.b
char* es
char temp1 = *(es + arg4)
*(es + arg4) += arg3.b
bool c = temp1 + arg3.b u< temp1
void* edi
edi.w = __return_addr:1.w
arg4.w = __return_addr:3.w
char* ebp
ebp.w = arg6
void arg_9
void* esp_1
esp_1.w = &arg_9
void* ebx
ebx.w = *esp_1
arg2.w = *(esp_1 + 2)
arg3.w = *(esp_1 + 4)
eax.w = *(esp_1 + 6)
int32_t eflags

if (&__return_addr == 0xffffffff)
    if (&__return_addr != 0xffffffff)
        uint16_t* esi = __outsd(arg2.w, *arg4, arg4, eflags)
        __outsb(arg2.w, *esi, esi, eflags)
        uint16_t* esi_2 = *(edi + (ebp << 1) + 0x72) * &data_401000
        *arg3
        ebx:1.b *= 2
        eax.b = 0xe3
        *arg3 -= 0x1d
        *eax -= 0x1d
        *eax -= 0x1d
        *eax -= 0x1d
        *eax = *eax
        *eax -= 0x1d
        int32_t eflags_1
        char temp0
        temp0, eflags_1 = __daa(0xe3, eflags)
        eax.b = temp0
        *eax += arg3.b
        __outsd(arg2.w, *esi_2, esi_2, eflags_1)
        int32_t eflags_2
        int16_t temp0_1
        temp0_1, eflags_2 = __arpl_memw_gpr16(*(ebx + 0x53), (&ebp[1]).w)
        *(ebx + 0x53) = temp0_1
        int32_t esi_4 = *(ebp - 0x3b) * 0x8f00451c
        *eax += eax.b
        *(edi + 0x1ff0000) -= 1
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        *eax += eax.b
        *eax -= eax.b
        *(arg2 + (esi_4 << 1) + 0x61) |= eax.b
        *(esp_1 + 9)
        *eax += eax.b
        jump(*(eax * 2))
    
    eax.b = sbb.b(eax.b, 0x45, c)
    *ebp += ebx.b
    ebx:1.b *= 2
    TEB* fsbase
    *(fsbase + eax) += eax.b
    *arg3 += 1
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax = *eax
    *eax += eax.b
    *eax -= eax
    *(arg2 + (arg4 << 1) + 0x61) |= eax.b

uint16_t* esi_5 = __outsd(arg2.w, *arg4, arg4, eflags)
char* gsbase
*(gsbase + eax) += arg2.b
eax[1] += arg2.b
arg2:1.b += ebx:1.b
*(esp_1 + 4) = 0xd4fe0000
void* esp_4 = esp_1 + 4
eax[1] += (&eax[1]).b
eax[1] += (&eax[1]).b
*arg3 = *arg3
eax[1] += (&eax[1]).b
*esp_4
__outsb(arg2.w, *esi_5, esi_5, eflags)
*(esp_4 + 2)
uint16_t* esi_7 = *(esp_4 + 6)
void* ebp_3 = *(esp_4 + 0xa)
int16_t ebx_2 = (*(esp_4 + 0x12)).w
int32_t edx = *(esp_4 + 0x16)
char* ecx = *(esp_4 + 0x1a)
char* eax_2 = *(esp_4 + 0x1e)
__bound_gprv_mema32(ebp_3, *(ebp_3 + 0x64))
*eax_2 += edx.b
*ecx += ebx_2.b
ebx_2:1.b *= 2
void* eax_3
eax_3.b = (&eax_2[1]).b + 0x79
*ecx += eax_3.b
*eax_3 += eax_3.b
*eax_3 += eax_3.b
*eax_3 += eax_3.b
*eax_3 = *eax_3
*eax_3 += eax_3.b
void* eax_4 = eax_3 - *eax_3
char temp3 = edx.b
edx.b |= *(eax_4 + 0x61)
bool z = (temp3 | *(eax_4 + 0x61)) == 0
__outsb(edx.w, *esi_7, esi_7, eflags)

if (not(z))
    jump(0x46a9a7)

*(esp_4 + 0x1e) = esp_4 + 0x22
*eax_4 = adc.b(*eax_4, eax_4.b, false)
*eax_4 += eax_4.b
undefined
