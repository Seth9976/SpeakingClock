// 函数: sub_497823
// 地址: 0x497823
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 -= 1
*arg1 += arg1.b
*(arg3 + (arg4 << 1) + 0x73) += arg1.b
void* const __return_addr_1 = __return_addr
void* esi = arg5
void* ebp = arg6
char* ebx = arg7
char* arg_18
char* ecx = arg_18
void arg_20
void* esp_1 = &arg_20
__bound_gprv_mema32(ebp, *(ebp + 0x64))
*arg9 += arg9.b
*arg9 += arg9.b
arg9[0x49]
*arg9 += arg9.b
*arg9 += arg9.b
*arg9 += arg9.b
*arg9 += arg9.b
*arg9 += arg9.b
*arg9 += arg9.b
*0x4978 += 0x78
*0x4978 += 0x78
*0x4978 += 0x78
*0x4978 += 0x78
*0x4978 += 0x78
*0x1c0092f0 = *0x1c0092f0
*0x4978 += 0x78
ecx[(__return_addr_1 << 1) + 0x41] = ecx[(__return_addr_1 << 1) + 0x41]
*0xbc0089b6 += arg8:1.b
*0x7d32 += ebx:1.b
*(&arg_20 + __return_addr_1) += ebx.b
*0x3cf5
*0x3cf5 += arg8:1.b
bool p = unimplemented  {add byte [eax], dh}
char* eax_1
int16_t* ecx_7

if (p)
    eax_1.b = 0xf5 + arg8:1.b
    *esi - *__return_addr_1
    char* esi_1 = esi + 4
    void* edi = __return_addr_1 + 4
    arg8[edi << 1] += eax_1.b
    eax_1[0x7b] += 0x3c
    *eax_1 += arg8.b
    *edi = eax_1
    void* edi_1 = edi + 4
    eax_1.b += arg8:1.b
    *edi_1 = eax_1
    __return_addr_1 = edi_1 + 4
    *eax_1 += 0x3c
    eax_1.b = *esi_1
    void* esi_2 = &esi_1[1]
    *eax_1 += ebx.b
    eax_1.b = *esi_2
    esi = esi_2 + 1
    ecx_7 = &ecx[3]
    
    while (true)
        eax_1:1.b *= 2
        bool p_1 = unimplemented  {add ah, ah}
        
        if (p_1)
            *eax_1 = &eax_1[*eax_1]
            goto label_4978ea
        
        char temp10_1 = *arg8
        *arg8 += arg8.b
        *(esp_1 - 4) = esp_1
        ebp -= 1
        void* ebx_1 = &ebx[1]
        esi += 1
        ebx = ebx_1 + 1
        *(esp_1 - 8) = ebx
        esp_1 -= 8
        
        if (ebx_1 != 0xffffffff)
            if (ebx_1 != 0xffffffff)
                __bound_gprv_mema32(ebp, *(arg8 + 0x65))
                int32_t eflags_1
                int16_t temp0_1
                temp0_1, eflags_1 = __arpl_memw_gpr16(*(eax_1 + (arg8 << 2) - 0x48), esi.w)
                *(eax_1 + (arg8 << 2) - 0x48) = temp0_1
                
                if (__return_addr_1 - 1 s< 0)
                    char temp13 = eax_1[0x53080000]
                    eax_1[0x53080000] += eax_1.b
                    
                    if (temp13 == neg.b(eax_1.b))
                        jump(0x49797d)
                    
                    jump(0x497909)
                
                char temp14 = *(__return_addr_1 - 1)
                *(__return_addr_1 - 1) += eax_1.b
                char* edx
                edx.b = adc.b(arg8.b, *(esp_1 + (ecx_7 << 1) + 0x4d), temp14 + eax_1.b u< temp14)
                *(esp_1 - 3) = &ebx[2]
                
                if (ebx == 0xfffffffe)
                    jump(0x497925)
                
                jump("teObject")
            
            ecx_7 -= 1
        else if (temp10_1 + arg8.b u>= temp10_1)
            continue
        else
            eax_1 = &eax_1[1]
            *(&ecx_7[__return_addr_1] + 0x49) += ebx.b
        
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *(&ecx_7[__return_addr_1] + 0x49) += ebx.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *(ecx_7 + 0x49)
        *eax_1 += eax_1:1.b
        *eax_1 += eax_1.b
        eax_1[0x65] += ecx_7.b
        eax_1 -= 1
        break
    
    goto label_49793b

arg9 = 0x65
int32_t eflags_2
int16_t temp0_2
temp0_2, eflags_2 = __arpl_memw_gpr16(*0x13141, esi.w)
*0x13141 = temp0_2
ecx_7 = ecx - 1
eax_1.b = 0xf5 + arg8:1.b

if (0xf5 + arg8:1.b s< 0)
    *ecx_7 += eax_1.b
    *ecx_7 += arg8.b
    ebp -= 1
    void* ebx_4 = &ebx[1]
    esi += 1
    ebx = ebx_4 + 1
    arg_18 = ebx
    esp_1 = &arg_18
    
    if (ebx_4 == 0xffffffff)
        goto label_497943
    
    if (ebx_4 == 0xffffffff)
        goto label_497947
    
    __bound_gprv_mema32(ebp, *(arg8 + 0x65))
    int32_t eflags_3
    int16_t temp0_3
    temp0_3, eflags_3 = __arpl_memw_gpr16(*(ecx_7 + eax_1), esi.w)
    *(ecx_7 + eax_1) = temp0_3
label_4978ea:
    eax_1.b |= 0x7e
    *(eax_1 * 2) += arg8.b
    ebx:1.b *= 2
    trap(0xd)

*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 += eax_1.b
char temp3_1 = *eax_1
*eax_1 += eax_1.b
bool p_2 = unimplemented  {add byte [eax], al}
bool a_1 = unimplemented  {add byte [eax], al}
bool s_1 = temp3_1 + eax_1.b s< 0
bool d
arg_18 = (add_overflow(temp3_1, eax_1.b) ? 1 : 0) << 0xb | (d ? 1 : 0) << 0xa | (s_1 ? 1 : 0) << 7
    | (temp3_1 == neg.b(eax_1.b) ? 1 : 0) << 6 | (a_1 ? 1 : 0) << 4 | (p_2 ? 1 : 0) << 2
    | (temp3_1 + eax_1.b u< temp3_1 ? 1 : 0)
esp_1 = &arg_18

if (not(s_1))
    *(ecx_7 - 0x4edbffbf) &= arg8:1.b
else
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *(&ecx_7[__return_addr_1] + 0x200049) += eax_1.b
    *eax_1 += eax_1.b
    eax_1 -= 2
label_49793b:
    eax_1[0xbc00403e] += arg8:1.b
label_497943:
    void* eax_3
    eax_3.b = (&eax_1[1]).b * 2
    eax_1 = eax_3 + 1
label_497947:
    eax_1:1.b += eax_1.b
    eax_1[0x403f] += ebx:1.b
    *(esp_1 + __return_addr_1) += ebx.b
    *((__return_addr_1 << 1) + 0xa7f00049) += arg8.b
    char* eax_5
    eax_5.b = (&eax_1[2]).b + ebx:1.b
    *esi - *__return_addr_1
    void* esi_4 = esi + 4
    __return_addr_1 += 4
    *eax_5 += (&ecx_7[1]).b
    eax_1 = *esi_4
    esi = esi_4 + 4
    *(ecx_7 + 3 + (esi << 2)) += ebx.b
    *eax_1 += eax_1:1.b
    ecx_7.b = 0x41
    ecx_7[esi * 2].b += eax_1:1.b

*(ecx_7 + 1 + (esi << 2)) += arg8.b
char temp5 = eax_1:1.b
eax_1:1.b += arg8.b

if (temp5 s>= neg.b(arg8.b))
    eax_1[0x1c0041ad] += eax_1:1.b
    *__return_addr_1
    *ebx += arg8.b
    *(esp_1 - 4) = esp_1
    *(esp_1 - 8) = &ebx[2]
    
    if (ebx == 0xfffffffe)
        *eax_1 |= eax_1.b
        *eax_1 += eax_1.b
        *(esp_1 - 0xc) = esi + 1
        int32_t eax_9 = (*(**(eax_1 + 0x14) + 8))()
        *(esp_1 - 0xc)
        return eax_9
    
    if (ebx == 0xfffffffe)
        undefined
    
    return sub_497991(eax_1, arg8, ebp - 1, esi + 1, __return_addr_1 + 1, nop) __tailcall

char* esi_6 = *(esp_1 + 4)
int32_t ebx_7 = *(esp_1 + 0x10)
char ecx_16 = (*(esp_1 + 0x18)).b
int16_t* eax_7 = *(esp_1 + 0x1c)

if (temp5 == neg.b(arg8.b))
    eax_7.b += 0x5e
    *(esp_1 + 0x20)
    return eax_7

int32_t edi_6 = *esp_1 - 1
__bound_gprv_mema32(*(esp_1 + 8), *(*(esp_1 + 0x14) + 0x65))
int32_t eflags_4
int16_t temp0_4
temp0_4, eflags_4 = __arpl_memw_gpr16(*(eax_7 * 2), esi_6.w)
*(eax_7 * 2) = temp0_4
int32_t eflags_5
char temp0_5
char temp1_1
temp0_5, temp1_1, eflags_5 = __aam_immb(0x79, eax_7.b)
eax_7.b = temp0_5
eax_7:1.b = temp1_1
*esi_6 += ecx_16 - 1
int16_t cs
*(esp_1 + 0x1c) = zx.d(cs)
*(esp_1 + 0x18) = esp_1 + 0x1c
*(esp_1 + 0x14) = ebx_7

if (esp_1 != 0xffffffe8)
    if (esp_1 == 0xffffffe8)
        jump(0x497a44)
    
    jump(0x4979df)

*eax_7 += eax_7.b
*(esp_1 + 0x10) = ebx_7
*(esp_1 + 0xc) = esi_6
*(esp_1 + 8) = edi_6
sub_41ece4()
*(esp_1 - 8) = 0
jump(sub_497a33+0x44)
