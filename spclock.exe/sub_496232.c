// 函数: sub_496232
// 地址: 0x496232
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

char* entry_ebx
*(entry_ebx * 2) += (arg2 + 1):1.b
int32_t ebx
ebx:1.b = arg3:1.b * 2
*(arg1 * 3) ^= entry_ebx:1.b
*entry_ebx = &entry_ebx[*entry_ebx]
*entry_ebx += entry_ebx.b
char* eax
eax.b = entry_ebx.b + *entry_ebx
char temp1 = *eax
*eax += eax.b
*eax = adc.b(*eax, eax.b, temp1 + eax.b u< temp1)
ebx:1.b *= 2
int32_t edx_1 = (arg2 + 1) | *(ebx + 0x68)
int32_t eflags
TEB* fsbase
uint16_t* result = __outsd(arg7, *(fsbase + arg4), arg4, eflags)

if (edx_1 u> 0)
    *arg9 += arg9.b
    uint64_t* eax_1
    eax_1.b = arg9.b - 1
    
    if (arg9.b != 1)
        return result
    
    if (*(arg6 + 0x39) == 0)
        return zx.d(*(arg6 + 0x20)) + 2
    
    return nullptr

uint16_t* esi_1 = __outsd(arg7, *result, result, eflags)
uint8_t* edi_1
uint8_t temp0
temp0, edi_1 = __insb(__return_addr, arg7, eflags)
*edi_1 = temp0
uint16_t* esi_2 = __outsd(arg7, *esi_1, esi_1, eflags)

if (edx_1 u>= 0)
    int32_t ecx_1
    int16_t es
    ecx_1, es = __les_gprz_memp(*arg9)
    *arg9
    int32_t eax_2 = sx.d(arg9.w)
    *(ecx_1 - 1) += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *(eax_2 * 2) = *(eax_2 * 2)
    *(eax_2 * 2) += (ecx_1 - 1).b
    
    if ((eax_2 | 0x6e617453) u< 0)
        jump(sub_496280+0x5e)
    
    jump(0x49627a)

uint16_t* esi_6 = __outsd(arg7, *esi_2, esi_2, eflags)

if (edx_1 u< 0)
    if (edx_1 == 0)
        jump(sub_496280+0x76)
    
    jump(0x49627d)

int32_t ecx_4
int16_t es_1
ecx_4, es_1 = __les_gprz_memp(*arg9)
*arg9 ^= arg9.b
void* ebx_1
ebx_1:1.b = arg6:1.b * 2
*(ecx_4 * 3) &= 1
*arg9 += arg9.b
*arg9 += arg9.b
*arg9 += arg9.b
*arg9 = *arg9
*(arg9 + 0x4d04000a) += arg9.b
__outsd(arg7, *esi_6, esi_6, eflags)
undefined
