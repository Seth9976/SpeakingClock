// 函数: sub_44a06f
// 地址: 0x44a06f
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

void arg_45
*(&arg_45 + (arg4 << 3)) += arg2:1.b
char temp1 = *(arg1 + 1)
*(arg1 + 1) += arg1.b
bool c = temp1 + arg1.b u< temp1
int32_t temp3 = *arg1
char* eax = adc.d(arg1, temp3, c)
bool z = adc.d(arg1, temp3, c) == 0
int32_t esi
int32_t var_1 = esi
void* entry_ebx
*(entry_ebx + 0x69)
uint16_t* esi_1 = *(entry_ebx + 0x69) * 0x2c656c62
bool o = unimplemented  {imul esi, dword [ebx+0x69], 0x2c656c62}
int32_t eflags

if (not(o))
label_44a0cd:
    
    if (not(z))
        int32_t* edi
        int32_t temp0_3
        temp0_3, edi = __insd(arg5, arg2.w, eflags)
        *edi = temp0_3
        int32_t eflags_1
        char temp0_4
        char temp1_1
        temp0_4, temp1_1, eflags_1 = __aam_immb(0x9a, eax.b)
        eax.b = temp0_4
        eax:1.b = temp1_1
        eax[0x98ff0000] += entry_ebx.b
        *eax += eax.b
        *arg3 += 1
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        char temp7 = eax[0x4f120016]
        eax[0x4f120016] += eax.b
        uint64_t* esi_3 = __outsb(arg2.w, *esi_1, esi_1, eflags_1)
        
        if (arg3 != 0xffffffff && temp7 + eax.b u>= temp7)
            jump("ncedDrawItem")
        
        eax.b *= 2
        *arg2
        void* eax_3 = eax ^ *arg2
        char* edi_1
        int16_t es_1
        edi_1, es_1 = __les_gprz_memp(*esi_3)
        *(eax_3 + 0x403f) += entry_ebx:1.b
        *(0xfc00403e + edi_1) += entry_ebx.b
        char* eax_5
        eax_5.b = (eax_3 + 2).b + (arg3 + 2).b
        *(eax_5 * 2 - 0x10)
        *edi_1 += (arg3 + 2).b
        *eax_5 += (arg3 + 3).b
        eax_5.b += *arg4
        *edi_1 = *esi_3
        void* edi_2 = &edi_1[1]
        void* esi_4 = esi_3 + 1
        eax_5.b += *arg4
        eax_5.b = *esi_4
        void* esi_5 = esi_4 + 1
        int32_t eflags_2
        char temp0_5
        char temp1_2
        temp0_5, temp1_2, eflags_2 = __aaa(eax_5.b, eax_5:1.b, eflags_1)
        eax_5.b = temp0_5
        eax_5:1.b = temp1_2
        *(eax_5 + edi_2 + 0x3ad80042) += eax_5:1.b
        *(edi_2 + esi_5 + 0x37b40042) += entry_ebx:1.b
        eax_5.b += eax_5:1.b
        eax_5.b = sbb.b(eax_5.b, 0xf7, eax_5.b u< *(arg2 + 4))
        eax_5.b += (arg2 + 4):1.b
        int32_t temp10 = *arg4
        *arg4 = &eax_5[*arg4]
        eax_5.b = sbb.b(eax_5.b, 0xf8, &eax_5[temp10] u< temp10)
        *eax_5 += eax_5:1.b
        eax_5.b += *arg4
        int16_t cs
        *0xfc00403c = zx.d(cs)
        *eax_5 += eax_5.b
        *eax_5 += eax_5.b
        *(arg3 + 3) += eax_5.b
        *eax_5 += eax_5.b
        *(eax_5 + arg2 + 4 + 0x3c0040) += entry_ebx:1.b
        *eax_5 += eax_5.b
        eax_5.b = eax_5.b
        undefined
else
    eax[0x88ff0000] += arg3.b
    *eax += eax.b
    char* eax_1
    uint16_t edx
    eax_1, edx = (&var_1)()
    eax_1.b = __in_al_dx(edx, eflags)
    *eax_1 += eax_1.b
    *eax_1 += eax_1.b
    *eax_1 = *eax_1
    eax_1[0x4f070014] += eax_1.b
    uint16_t* esi_2 = __outsb(edx, *esi_1, esi_1, eflags)
    entry_ebx += 1
    uint8_t temp0_2
    temp0_2, arg5 = __insb(arg5, edx, eflags)
    *arg5 = temp0_2
    void* esp_2 = *(entry_ebx + 0x6b) * &data_449a68
    *eax_1 += eax_1.b
    eax, arg2, arg3 = (*(eax_1 + 0x1ff0000))()
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax = *eax
    char temp5_1 = eax[0x4f0a0015]
    eax[0x4f0a0015] += eax.b
    bool c_1 = temp5_1 + eax.b u< temp5_1
    esi_1 = __outsb(arg2.w, *esi_2, esi_2, eflags)
    z = esp_2 == 0xffffffff
    
    if (not(c_1))
        if (not(z) && not(c_1))
            jump(0x44a116)
        
        goto label_44a0cd
    
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
char* eax_2 = *0x44
*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 += eax_2.b
return arg6 - arg7
