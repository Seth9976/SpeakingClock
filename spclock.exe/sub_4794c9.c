// 函数: sub_4794c9
// 地址: 0x4794c9
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

int16_t* entry_ebx
__bound_gprv_mema32(arg4, *(entry_ebx + 0x59))
int32_t eflags
bool c

if (c)
    __bound_gprv_mema32(arg4, *(entry_ebx + 0x4e))
    arg5 = __outsd(arg2.w, *arg5, arg5, eflags)

__bound_gprv_mema32(arg4, *(entry_ebx + 0x43))
uint8_t* edi
uint8_t temp0
temp0, edi = __insb(arg6, arg2.w, eflags)
*edi = temp0
uint16_t* esi = __outsd(arg2.w, *arg5, arg5, eflags)
bool s

if (not(c))
    bool o
    
    if (s != o)
        *arg1 += arg1.b
        *arg1 += arg1.b
        *(esi + 0x47)
        *arg1 += arg1.b
        *arg1 += arg1.b
        *arg1 += arg1.b
        arg1.b ^= 0x96
        arg1[0xffffff96] += entry_ebx:1.b
        edi = &edi[2]
        arg1[2] += entry_ebx:1.b
        *arg1 += arg1.b
        arg2[0x43] = arg2[0x43]
        *arg2 s>>= 0x42
        *(esi + edi + 0x33fc0040) += entry_ebx:1.b
        arg2 = &arg2[1]
        arg1:1.b += arg1.b
        arg1 = &arg1[1]
        *(&esi[arg3 * 4] + 0x45) += entry_ebx:1.b
    
    *arg1 += arg1.b
    *(&__return_addr:2 + edi) += entry_ebx.b
    arg1 = &arg1[1]
    *(edi * 5 + 0x5300047) += arg3:1.b
    *(esi + 1 + (edi << 2)) += entry_ebx:1.b
    *edi += arg3.b
else
    __bound_gprv_mema32(arg4, *(entry_ebx + 0x41))
    __bound_gprv_mema32(arg4, *(edi + 0x72))
    bool z
    
    if (not(z))
        __bound_gprv_mema32(arg4, *(entry_ebx + 0x52))
        
        if (z)
            if (z)
                jump(0x4794fd)
            
            jump(0x47955e)
        
        if (s)
            jump(0x4794ec)
        
        goto label_4794f9
    
    char temp1_1 = arg2[0x6b] | arg1:1.b
    arg2[0x6b] = temp1_1
    arg3 -= 1
    esi.w = __outsb(arg2.w, *esi, esi.w, eflags)
    int32_t esi_1 = __outsd(arg2.w, *esi, esi, eflags)
    
    if (temp1_1 u>= 0)
    label_4794f9:
        uint8_t* edi_1
        uint8_t temp0_2
        temp0_2, edi_1 = __insb(edi, arg2.w, eflags)
        *edi_1 = temp0_2
        
        if (arg2 != 0xffffffff)
            jump(0x479572)
        
        jump(0x4794fe)
    
    *esi_1 - *edi
    edi = &edi[4]
edi[(entry_ebx << 2) + 0x45] += arg2:1.b
arg1[(edi << 2) + 0x45] += arg2.b
*arg1 += entry_ebx:1.b
arg1.b += entry_ebx.b
*arg2
int32_t eflags_1
char temp0_3
char temp1_2
temp0_3, temp1_2, eflags_1 = __aaa(arg1.b, arg1:1.b, eflags)
arg1.b = temp0_3
arg1:1.b = temp1_2
arg1.b += arg1:1.b
arg2[1]
arg1[5] += arg1:1.b
*(arg1 + 0x1cb8427d) += (arg3 + 1):1.b
arg1.b += (&arg2[1]).b
arg1.b += (&arg2[1]):1.b
*0xf9f402cd += entry_ebx.b
arg1.b += entry_ebx:1.b
arg1:1.b += entry_ebx:1.b
*(arg3 + 0x46) += arg1.b
arg1[0xffffffa1] += (&arg2[1]):1.b
*arg1 += entry_ebx:1.b
*0xb4004233 = 0x45
*(arg4 + 0x68dc00dd) += arg1:1.b
char temp3 = *arg1
*arg1 += (&arg2[1]):1.b

if (temp3 != neg.b((&arg2[1]):1.b) && temp3 + (&arg2[1]):1.b u>= temp3)
    trap(0xd)

char temp4 = arg1[0xf000460e]
arg1[0xf000460e] += arg1.b

if (temp4 + arg1.b s< 0)
    jump(0x4795c3)

int32_t eax_1 = sx.d(arg1.w)
*(eax_1 + (edi << 3) - 0x2ed7ffbb) += entry_ebx.b
*(arg3 + 0xa90c427a) += (&arg2[1]):1.b
*(arg3 + 0xd400047) += eax_1.b
*(eax_1 + (edi << 3)) += eax_1.b
eax_1:1.b += entry_ebx.b
*entry_ebx
eax_1.b += eax_1:1.b
*(eax_1 * 9) += eax_1:1.b
*(entry_ebx + 1) += (arg3 + 1).b
*(0xb4004233 + (&edi[1] << 2)) += (arg3 + 1):1.b
*(arg3 + 0x20f00cf8)
eax_1.b = 0x14
eax_1.b = 3
void* ecx
ecx:1.b = (arg3 + 1):1.b + (entry_ebx + 1):1.b
undefined
