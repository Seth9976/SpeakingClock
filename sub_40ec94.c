// 函数: sub_40ec94
// 地址: 0x40ec94
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

char* eax
bool c
eax.b = sbb.d(arg1, 0xf8000000, c).b + (arg2 - 1):1.b
eax.b += arg3:1.b
eax.b += eax:1.b
int32_t entry_ebx
eax.b += entry_ebx.b
eax.b += (arg2 - 5).b
eax.b += arg3.b
eax.b *= 2
eax[0xf4004aa9] += entry_ebx:1.b
*(arg2 - 8) = ror.d(*(arg2 - 8), 0xb0)
eax[0x68004aa9] += arg3:1.b
*(arg2 - 9) = ror.d(*(arg2 - 9), 0xa0)
eax[0x24004aa9] += entry_ebx.b
char ecx
int16_t es
ecx, es = __les_gprz_memp(*(arg2 - 0xa))
eax[0xac004aa9] += ecx
void* ecx_1
int16_t es_1
ecx_1, es_1 = __les_gprz_memp(*(arg2 - 0xb))
*(ecx_1 - 0x3d43ffb6) -= 0x4a
eax[0xffffffa9] += entry_ebx:1.b
*(arg2 - 0xc + (eax << 3) - 0x568fffb6) += ecx_1.b
eax.b *= 2
int32_t ecx_2
int16_t es_2
ecx_2, es_2 = __les_gprz_memp(*(arg2 - 0xd))
int32_t var_4 = 0x6c004aa9
int32_t ecx_3
int16_t es_3
ecx_3, es_3 = __les_gprz_memp(*(arg2 - 0xd))
char* var_8 = eax
int32_t var_c = ecx_3
void* var_10 = arg2 - 0xd
int32_t var_14 = entry_ebx
int32_t* var_18 = &var_14
int32_t var_1c = arg4
eax[0xffffffa9] += entry_ebx.b
*eax += (arg2 - 0xf):1.b
void* ecx_4
int16_t es_4
ecx_4, es_4 = __les_gprz_memp(*(arg2 - 0xf))
char* var_28 = eax
eax[0xffffffa9] += ecx_4.b
eax[0x40004ac0] += entry_ebx.b
*eax += entry_ebx:1.b
*eax += ((arg2 - 0xf).w - 4):1.b
*eax += ecx_4:1.b
*eax += eax:1.b
*eax += entry_ebx.b
*eax += ecx_4:1.b
*eax += eax.b
*eax += ((arg2 - 0xf).w - 8).b
*eax += eax.b
*eax += eax.b
*(ecx_4 + (arg4 << 2)) += ecx_4.b
eax:1.b += ecx_4.b
*eax += eax.b
*(ecx_4 - 0x3cd7ffb6) |= ecx_4:1.b
*eax += eax.b
*eax += eax.b
*(ecx_4 + (arg4 << 2)) += eax.b
*0x1bc += entry_ebx.b
*eax += eax.b
*(ecx_4 - 0x3f93ffb6) += ecx_4:1.b
*eax += eax.b
*eax += eax.b
eax:1.b += entry_ebx:1.b
*(eax * 9 + 0x4a) += eax:1.b
*eax += eax.b
*eax += eax.b
eax.b += entry_ebx:1.b
eax:1.b += ((arg2 - 0xf).w - 0xd):1.b
*eax += eax.b
trap(0xd)
