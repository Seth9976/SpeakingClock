// 函数: sub_426ff4
// 地址: 0x426ff4
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

arg1.b ^= 0xc3
char* entry_ebx
*(arg1 - 0x49) += entry_ebx.b
int32_t ecx_1 = arg3 + 2
char temp1 = *(arg1 + 0x1000427d)
*(arg1 + 0x1000427d) += arg1:1.b
int32_t eflags
void* esp_1
void* const* var_4

if (temp1 == neg.b(arg1:1.b) || temp1 + arg1:1.b s< 0 != add_overflow(temp1, arg1:1.b))
    __builtin_strncpy(&var_4, "edSt", 4)
    esp_1 = &var_4
    
    if (temp1 + arg1:1.b u< temp1)
        goto label_4270b5
    
    __outsb(arg2.w, *arg5, arg5, eflags)
    void var_5
    esp_1 = &var_5
    arg5 = *(entry_ebx + 0x74) * 0x7058c08b
    arg2 += 1
label_427057:
    char temp4_1 = *arg6
    *arg6 += arg1.b
    bool c_2 = temp4_1 + arg1.b u< temp4_1
    int32_t temp5_1 = *(arg1 + (ecx_1 << 1) + 0x61)
    *(arg1 + (ecx_1 << 1) + 0x61) = adc.d(temp5_1, arg2, c_2)
    
    if (adc.d(temp5_1, arg2, c_2) u>= temp5_1 && (not(c_2) || adc.d(temp5_1, arg2, c_2) != temp5_1))
        goto label_4270c7
    
    *(esp_1 - 4) = entry_ebx
    esp_1 -= 4
    
    if (adc.d(temp5_1, arg2, c_2) != 0)
        *(arg5 + 0x67)
        arg5[arg6].b += ecx_1.b
        *arg1 += arg1.b
        *arg1 += ecx_1.b + 1
        int16_t eax_1 = (*(__outsb(arg2.w + 1, *arg5, arg5, eflags) + 0x69)).w * 0x656c
        char temp9 = eax_1:1.b
        eax_1:1.b += ecx_1.b
        
        if (add_overflow(temp9, ecx_1.b))
            jump(0x4270c5)
        
        jump(&data_427080:3)
else
    *(arg2 + (arg6 << 2) + 0x41) += arg1.b
    *((arg1 << 3) + 0xc51c0041) += ecx_1.b
    *(arg1 - 0x3ffbe46) += (ecx_1.w + 1):1.b
    *((arg6 << 2) + 0xbd940041) += entry_ebx:1.b
    arg5[arg6 * 2].b += (ecx_1.w + 3):1.b
    *(arg4 + (arg6 << 1) + 0x42) += 0x41
    *((arg1 << 3) + 0xbba80082) += (ecx_1.w + 4):1.b
    *(arg1 - 0x3b) = *(arg1 - 0x3b)
    entry_ebx[(arg1 << 3) - 0x386fffbf] = entry_ebx[(arg1 << 3) - 0x386fffbf]
    char temp2_1 = *(arg1 + 0x110041c7)
    *(arg1 + 0x110041c7) += arg1:1.b
    var_4 = &__return_addr
    arg6 = var_4
    arg5 = __return_addr
    arg4 = arg8
    entry_ebx = arg9
    arg2 = arg10
    ecx_1 = arg11
    char* arg_18
    char* eax = arg_18
    void arg_1c
    esp_1 = &arg_1c
    void* eax_4
    void* eax_3
    
    if (temp2_1 + arg1:1.b u>= temp2_1)
        *(arg5 + arg6 + 0x3ec00040) += entry_ebx:1.b
        eax_3 = &eax[2]
    label_4270b7:
        eax_3:1.b += eax_3.b
        eax_4 = eax_3 + 1
        *(eax_4 + 0x403e) += entry_ebx:1.b
    else
        arg_18 = entry_ebx
        esp_1 = &arg_18
        
        if (arg1 != 1)
            *(arg5 + 0x67)
            arg4 = *(arg5 + 0x67) * 0x7473694c
            bool o_1 = unimplemented  {imul ebp, dword [esi+0x67], 0x7473694c}
            arg1 = arg_18
            esp_1 = &arg_1c
            
            if (not(o_1))
                goto label_427057
            
            *arg1 += arg1.b
            *arg1 += arg1.b
            *arg1 += arg1.b
            *(ecx_1 + (arg5 << 1)) += ecx_1:1.b
            arg2 += 1
            *(arg1 * 2) += ecx_1.b
            *arg1 += arg1.b
            *(arg4 + 0x42)
            *(arg1 - 0x43ffbfc2) += arg2:1.b
            arg1.b = (arg1 + 1).b * 2
        label_4270b5:
            eax_3 = arg1 + 1
            goto label_4270b7
        
        eax_4 = &eax[1]
        *eax_4 += eax_4.b
    *(esp_1 + arg6) += entry_ebx.b
    arg1 = eax_4 + 1
label_4270c7:
    arg1.b += ecx_1.b
    *arg2 += 0x2c
    *arg2
    *(arg1 + 0x71740042) = adc.b(*(arg1 + 0x71740042), ecx_1.b, false)
*(arg2 + 1 + (arg5 << 1) + 0x42) += arg1.b
char temp8 = *(arg1 + 0x58004272)
*(arg1 + 0x58004272) += arg1:1.b
bool z_2 = temp8 == neg.b(arg1:1.b)

if (z_2 || temp8 + arg1:1.b u< temp8)
    char temp10 = arg1:1.b
    char temp11 = arg1:1.b
    arg1:1.b *= 2
    bool c_5 = temp10 + temp11 u< temp10
    bool z_3 = temp10 == neg.b(temp11)
    
    if (not(z_3) && not(c_5))
        if (not(z_3) && not(c_5))
            undefined
        
        jump(0x42712b)
    
    char temp12 = arg1:1.b
    arg1:1.b += ecx_1.b
    
    if (temp12 + ecx_1.b u< temp12)
        jump(0x42712d)
    
    jump(0x4270eb)

int32_t* temp0 = *(arg2 + 1)
*(arg2 + 1) = arg1

if (z_2)
    (**temp0)()
    int32_t eax_9 = *(arg4 - 4)
    
    if (eax_9 != 0)
        eax_9 = *(eax_9 - 4)
    
    if (eax_9 s<= 2)
        jump(sub_427174+0x4d)
    
    jump(sub_427174+0x42)

*entry_ebx += ecx_1.b
*(esp_1 - 4) = esp_1
int32_t* edi
int32_t temp0_1
temp0_1, edi = __insd(arg6, (arg2 + 2).w, eflags)
*edi = temp0_1
void* eax_6 = *(__outsb((arg2 + 2).w, *arg5, arg5, eflags) + 0x69) * 0x5653656c
*(esp_1 - 8) = edi

if ((arg2 + 2).b != 0)
    eax_6 = sub_403fcc(ecx_1 - 1, arg2 + 2)

sub_404bdc(eax_6 + 4, ecx_1 - 1)

if ((arg2 + 2).b == 0)
    jump(sub_427138+0x34)

jump(sub_427138+0x25)
