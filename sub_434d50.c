// 函数: sub_434d50
// 地址: 0x434d50
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg3 += 1
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 = *arg1
*arg1 += arg1.b
char temp1 = *arg1
*arg1 += arg3.b
void* esp_1 = &__return_addr:3

if (temp1 + arg3.b u< temp1)
    goto label_434dc4

int32_t eflags
int32_t esi = __outsd(arg2.w, *arg5, arg5, eflags)
*(arg2 + 0x64ff0001) += (&arg1[1]):1.b
*esi - *arg6
*(arg3 - 1) += (&arg1[1]).b
arg1[1] += (&arg1[1]).b
arg1[1] += (&arg1[1]).b
arg1[1] += (&arg1[1]).b
arg1[1] = arg1[1]
char temp4_1 = arg1[1]
arg1[1] += (&arg1[1]).b
arg1[1] = sbb.b(arg1[1], (&arg1[1]).b, temp4_1 + (&arg1[1]).b u< temp4_1)
bool c_2 = unimplemented  {sbb byte [eax], al}
char temp6_1 = adc.b(*(arg4 + 0x6b), (&arg1[1]).b, c_2)
*(arg4 + 0x6b) = temp6_1
uint8_t* edi_1
uint8_t temp0_1
temp0_1, edi_1 = __insb(arg6 + 1, arg2.w, eflags)
*edi_1 = temp0_1
*(arg1 + 0x74)
uint16_t* esi_2 = *(arg1 + 0x74) * 0x6f507369
bool c_3 = unimplemented  {imul esi, dword [eax+0x73], 0x6f507369}
void* eax_2
void* entry_ebx
void* esp_2
int16_t es

if (c_3)
    if (temp6_1 == 0)
        goto label_434dfc
    
    uint16_t* esi_3 = __outsd(arg2.w, *esi_2, esi_2, eflags)
    uint16_t* esi_4 = __outsb(arg2.w, *esi_3, esi_3, eflags)
    arg1[1] += arg2.b
    arg1[2] += arg2.b
    arg2:1.b += (entry_ebx + 2):1.b
    int16_t var_1_1 = 0
    arg1[2] += (&arg1[2]).b
    arg1[2] += (&arg1[2]).b
    *(arg3 - 1) = *(arg3 - 1)
    char temp9_1 = arg1[2]
    arg1[2] += (&arg1[2]).b
    *(arg1 + 2) = sbb.d(*(arg1 + 2), &arg1[2], temp9_1 + (&arg1[2]).b u< temp9_1)
    es = var_1_1
    __outsb(arg2.w, *esi_4, esi_4, eflags)
    arg6 = __return_addr
    arg5 = arg7
    arg4 = arg8
    arg2 = arg10
    arg3 = arg11
    void arg_21
    esp_1 = &arg_21
    __bound_gprv_mema32(arg4, *(arg4 + 0x64))
    *0x1980045 <<= 1
    entry_ebx:1.b = arg9:1.b * 2
    arg1 = 0x10043a6
    *0x10043a6 -= 0x5a
label_434dc4:
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 = *arg1
    arg1[0x460c001a] += arg1.b
    uint16_t* esi_6 = __outsd(arg2.w, *arg5, arg5, eflags)
    int16_t temp0_2
    temp0_2, eflags = __arpl_memw_gpr16(*(arg4 + 0x73), esi_6.w)
    *(arg4 + 0x73) = temp0_2
    uint16_t* esi_7 = __outsd(arg2.w, *esi_6, esi_6, eflags)
    uint16_t* esi_8 = __outsb(arg2.w, *esi_7, esi_7, eflags)
    int16_t ebx_2
    
    if (entry_ebx != 0xffffffff)
        __outsd(arg2.w, *esi_8, esi_8, eflags)
        uint8_t* edi_2
        uint8_t temp0_3
        temp0_3, edi_2 = __insb(arg6, arg2.w, eflags)
        *edi_2 = temp0_3
        *arg1 += arg3:1.b
        ebx_2:1.b = (entry_ebx.w + 1):1.b * 2
        breakpoint
    
    *arg3 += (entry_ebx.w + 1).b
    ebx_2:1.b = (entry_ebx.w + 1):1.b * 2
    eax_2.b = (&arg1[1]).b + 0x79
    *arg3 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *arg3 = *arg3
    *eax_2 += eax_2.b
    int16_t ds
    *(esp_1 - 4) = zx.d(ds)
    esp_2 = esp_1 - 4
    goto label_434e63

uint16_t* esi_10 = __outsd(arg2.w, *esi_2, esi_2, eflags)
esi_2 = __outsb(arg2.w, *esi_10, esi_10, eflags)
label_434dfc:
arg1[1] = adc.b(arg1[1], (&arg1[1]).b, c_3)
void* var_1_2 = &arg1[1]
void* var_5_1 = arg3 - 1
void* var_9 = arg2
void* var_d = entry_ebx + 2
uint8_t* var_1d_1 = edi_1
arg1[1] += (&arg1[1]).b
int32_t var_21_1 = *(arg1 + 1)
*(arg1 + 1) = &arg1[1 + *(arg1 + 1)]
arg1[1] += (&arg1[1]).b
arg1[1] += (&arg1[1]).b
char temp12_1 = arg1[2]
arg1[2] += (&arg1[1]).b
bool c_5 = temp12_1 + (&arg1[1]).b u< temp12_1
char temp13_1 = (&arg1[1]).b
void* eax
eax.b = sbb.b(temp13_1, 0, c_5)
bool c_6 = unimplemented  {sbb al, 0x0}
int16_t cs
uint16_t* esi_11 = zx.d(cs)
arg2 = arg4 - 1
arg3 = &var_d
eax_2 = var_d
esp_2 = &var_9
void* edx_2
void* ebp_3
void* esi_12
uint16_t* esi_13
uint8_t* edi_4

if (c_6)
    *eax_2 += eax_2.b
    *(eax_2 + 1) += eax_2.b
label_434e87:
    *esp_2
    char temp17_1 = *esi_11
    *esi_11 += arg3.b
    bool c_11 = temp17_1 + arg3.b u< temp17_1
    bool z_3 = temp17_1 == neg.b(arg3.b)
    *(esp_2 - 2) = eax_2
    edi_4 = *(esp_2 - 2)
    esi_12 = *(esp_2 + 2)
    ebp_3 = *(esp_2 + 6)
    *(esp_2 + 0xe)
    edx_2 = *(esp_2 + 0x12)
    arg3 = *(esp_2 + 0x16)
    eax_2 = *(esp_2 + 0x1a)
    esp_2 += 0x1e
    
    if (not(c_11))
        esi_12 = __outsb(edx_2.w, *esi_12, esi_12, eflags)
        
        if (z_3)
            *eax_2 += edx_2.b
            goto label_434ee6
        
        *(esp_2 - 4) = 0x6948776f
        __outsb(edx_2.w, *esi_12, esi_12, eflags)
        
        if (z_3)
            jump(0x434e3d)
        
        jump(0x434e99)
else
    esi_11 = __outsb(arg2.w, *esi_11, esi_11, eflags)
    
    if (sbb.b(temp13_1, 0, c_5) != 0)
        *(arg3 + (var_21_1 << 1) + 0x4d)
        eax_2 = *(arg3 + (var_21_1 << 1) + 0x4d) * 0x65646f
        bool c_7 = unimplemented  {imul eax, dword [ecx+ebp*2+0x4d], 0x65646f}
        *eax_2 = adc.b(*eax_2, eax_2.b, c_7)
        *eax_2 += eax_2.b
        esp_2 = &var_9:3
        
        if (&var_9:3 s>= 0)
            *eax_2 += eax_2.b
            *(arg3 + (eax << 1) + 0x45) -= 1
            goto label_434e7a
        
        *arg3 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *arg3 = *arg3
        *eax_2
        *eax_2 += eax_2.b
        bool c_9 = unimplemented  {sbb eax, 0x61500b00}
        
        if (c_9)
            jump(0x434ea8)
        
        jump("ntColor")
    
    *eax_2 += eax_2.b
    *esi_11 += esi_2.b
label_434e63:
    char temp3_1 = *arg2
    *arg2 += arg3.b
    bool c_10 = temp3_1 + arg3.b u< temp3_1
    bool z_2 = temp3_1 == neg.b(arg3.b)
    *(esp_2 - 4) = eax_2
    edi_4 = *(esp_2 - 4)
    esi_12 = *esp_2
    ebp_3 = *(esp_2 + 4)
    void* ebx_4 = *(esp_2 + 0xc)
    edx_2 = *(esp_2 + 0x10)
    arg3 = *(esp_2 + 0x14)
    eax_2 = *(esp_2 + 0x18)
    esp_2 += 0x1c
    
    if (not(c_10))
        esi_13 = __outsb(edx_2.w, *esi_12, esi_12, eflags)
        
        if (z_2)
            int32_t temp8_1 = *(eax_2 + 0x6f)
            *(eax_2 + 0x6f) |= edx_2
            uint16_t* gsbase
            __outsb(edx_2.w, *(gsbase + esi_13), esi_13, eflags)
            
            if ((temp8_1 | edx_2) != 0)
                jump(0x434ebd)
            
            jump(0x434ebd)
        
        uint16_t* esi_14 = __outsd(edx_2.w, *esi_13, esi_13, eflags)
        esi_11 = __outsb(edx_2.w, *esi_14, esi_14, eflags)
        *eax_2 = adc.b(*eax_2, eax_2.b, c_10)
        es = *eax_2
        ebx_4:1.b *= 2
        void* temp11_1 = esp_2
        esp_2 -= 1
        
        if (temp11_1 - 1 s< 0)
        label_434e7a:
            *arg3 += eax_2.b
            *eax_2 += eax_2.b
            *eax_2 += eax_2.b
            *eax_2 += eax_2.b
            *arg3 = *arg3
            *eax_2 += eax_2.b
            goto label_434e87
        
        *(eax_2 - 0x3300ffff) += eax_2:1.b
        *esi_11 - *edi_4
        esi_12 = esi_11 + 1
        edi_4 = &edi_4[1]
        ebx_4 += 1
        *arg3 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *arg3 = *arg3
        *eax_2 += eax_2.b
        goto label_434ed4
    
    *(eax_2 + 1) += eax_2.b
label_434ed4:
    *eax_2 &= eax_2
    eax_2 |= 0x776f6853
    arg3 = &arg3[1]
    int16_t temp0_4
    temp0_4, eflags = __arpl_memw_gpr16(*(ebx_4 + 0x65), esp_2.w)
    *(ebx_4 + 0x65) = temp0_4
    uint8_t temp0_5
    temp0_5, edi_4 = __insb(edi_4, edx_2.w, eflags)
    *edi_4 = temp0_5
    *(esp_2 - 4) = 0x10007261
    esp_2 -= 4
label_434ee6:
    eax_2 += 1
    char temp10_1 = *(ebp_3 + 0x28ff0000)
    *(ebp_3 + 0x28ff0000) += arg3.b
    
    if (temp10_1 + arg3.b s>= 0)
        *(esp_2 - 4) = *edi_4
        esp_2 -= 4
    label_434f38:
        *arg3 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 += eax_2.b
        *eax_2 = *eax_2
        *eax_2 += eax_2.b
        *(esp_2 - 4) = zx.d(es)
        char* edi_8 = *(esp_2 - 5)
        uint16_t* esi_21 = *(esp_2 - 1)
        int32_t ebp_4 = *(esp_2 + 3)
        int32_t ebx_8 = *(esp_2 + 0xb)
        int16_t edx_4 = (*(esp_2 + 0xf)).w
        char* ecx_2 = *(esp_2 + 0x13)
        char* eax_5 = *(esp_2 + 0x17)
        
        if (esp_2 - 5 s>= 0)
            ebx_8:1.b *= 2
            *ecx_2 &= eax_5.b
            ebx_8:1.b *= 2
            *eax_5 = &eax_5[*eax_5]
            *eax_5 += eax_5.b
            *eax_5 += eax_5.b
            eax_5[0x80000000] += eax_5.b
            *eax_5 -= eax_5.b
            *(esp_2 + 0x17) = zx.d(cs)
            edi_8 -= 1
        else
            if (esp_2 == 5)
                *eax_5 += edx_4.b
                *edi_8 += edx_4.b
                char temp23 = ebx_8:1.b
                char temp24 = ebx_8:1.b
                ebx_8:1.b *= 2
                
                if (temp23 == neg.b(temp24))
                    jump(sub_434f25+0x79)
                
                jump(0x434f59)
            
            *eax_5 += eax_5.b
            *eax_5 += eax_5.b
            *eax_5 += eax_5.b
            *eax_5 = *eax_5
            eax_5[0x4f0e0028] += eax_5.b
        
        uint16_t* esi_22 = __outsb(edx_4, *esi_21, esi_21, eflags)
        uint16_t* esi_23 = __outsd(edx_4, *esi_22, esi_22, eflags)
        uint16_t* esi_24 = __outsb(edx_4, *esi_23, esi_23, eflags)
        
        if (ebx_8 != 0xffffffff)
            if (ebx_8 + 1 s< 0)
                eax_5.b &= 0x45
                eax_5.b += (ebx_8.w + 1):1.b
                *eax_5 += eax_5.b
                undefined
            
            jump("Popup,qA")
        
        *eax_5 += eax_5.b
        char temp25 = eax_5[0x4f0a002b]
        eax_5[0x4f0a002b] += eax_5.b
        bool c_14 = temp25 + eax_5.b u< temp25
        uint16_t* esi_25 = __outsb(edx_4, *esi_24, esi_24, eflags)
        
        if (not(c_14))
            if (edi_8 == 1 || c_14)
                jump(0x4350b1)
            
            jump("rd$E")
        
        *eax_5 += eax_5.b
        eax_5[0x4f0f002e] += eax_5.b
        uint16_t* esi_26 = __outsb(edx_4, *esi_25, esi_25, eflags)
        __outsd(edx_4, *esi_26, esi_26, eflags)
        
        if (ebp_4 != 1)
            jump(sub_435055+0xd4)
        
        jump("eActivate")
    
    char temp14_1 = eax_2.b
    eax_2.b += edx_2:1.b
    
    if (temp14_1 + edx_2:1.b s< 0)
        goto label_434f38

*eax_2 += eax_2.b
*eax_2 += eax_2.b
*eax_2 = *eax_2
char temp16_1 = *(eax_2 + 0x53080022)
*(eax_2 + 0x53080022) += eax_2.b
*(esp_2 - 4) = 0x6948776f
esi_13 = __outsb(edx_2.w, *esi_12, esi_12, eflags)
*eax_2 = adc.b(*eax_2, eax_2.b, temp16_1 + eax_2.b u< temp16_1)
eax_2.b = *esi_13
void* esi_17 = esi_13 + 1
*esi_17 - *edi_4
void* esi_18 = esi_17 + 1
void* edi_5 = &edi_4[1]
eax_2:1.b += arg3:1.b
*esi_18 - *edi_5
arg3[0xff0001] += eax_2:1.b
*eax_2 += eax_2.b
*eax_2 = *eax_2
char temp28 = *(eax_2 + 0x540b0023)
*(eax_2 + 0x540b0023) += eax_2.b

if (temp28 + eax_2.b u< temp28)
    jump(0x434f86)

return sub_434f25(eax_2, edx_2, ebp_3, esi_18 + 1, edi_5 + 1, nop) __tailcall
