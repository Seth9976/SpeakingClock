// 函数: sub_4188e0
// 地址: 0x4188e0
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg3[0x41]
*arg1 += arg1.b
*arg1 += arg1.b
char temp1 = *arg1
*arg1 += arg1.b
TEB* fsbase
*(fsbase + arg3) = arg1
void* eax
void* edx
int16_t entry_ebx
char* esp

if (temp1 + arg1.b u< temp1)
    arg1[0x3d] += arg3:1.b
    arg1:1.b += entry_ebx:1.b
    *(arg6 + 0x3d000042) += arg3:1.b
    *(arg4 + arg6 + 0x42) += arg3.b
    *arg3 += arg1.b
    bool cond:0_1 = arg1 u>= 0x540c0042
    arg6 = *arg1
    arg5 = __return_addr
    entry_ebx = arg8
    edx = arg9
    arg1 = arg11
    int32_t arg_1c
    esp = &arg_1c
    
    if (cond:0_1)
        goto label_418913
    
    int32_t eflags_1
    char temp0_2
    temp0_2, eflags_1 = __arpl_memw_gpr16(*(arg10 + 0x63), arg1.w)
    *(arg10 + 0x63) = temp0_2
    
    if (arg2 != 0xfffffffd)
        uint16_t* esi_2 = __outsd(edx.w, *arg5, arg5, eflags_1)
        __outsb(edx.w, *esi_2, esi_2, eflags_1)
        undefined
    
    eax = 0x403e
else
    *(arg1 * 2) += arg2.b
    *arg1 += (&arg3[1]):1.b
    char temp0_1 = arg3[1]
    arg3[1] = arg1.b
    arg1.b = temp0_1
    *arg2 s>>= 0x42
    *((arg1 << 1) + 0x45740042) += (&arg3[1]).b
    edx = &arg2[1]
label_418913:
    arg1:1.b += arg1.b
    eax = &arg1[1]
    *(eax + 0x403e) += entry_ebx:1.b

*(esp + arg6) += entry_ebx.b
*(eax - 0xfffbdba) += (eax + 1):1.b
*arg5 - *arg6
void* esi = &arg5[2]
void* edi = arg6 + 4
*(eax + 0xc004248) += entry_ebx:1.b
*esi - *edi
void* esi_1 = esi + 4
void* edi_1 = edi + 4
*(edi_1 + esi_1 + 0x36640042) += entry_ebx.b
*(eax + 0x4a) += entry_ebx.b
*(eax + 1 + edi_1 + 0x3ad80042) += (eax + 1):1.b
*(edi_1 + esi_1 + 0x37b40042) += entry_ebx:1.b
*(edx + 4)
breakpoint
