// 函数: sub_4a0ba0
// 地址: 0x4a0ba0
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp0 = *arg1
*arg1 += arg1.b
bool p = unimplemented  {add byte [eax], al}
void* eax_1
char* entry_ebx
char* esp

if (temp0 + arg1.b s< 0)
    if (p)
        *arg1
    
    int16_t es_1
    eax_1, es_1 = __les_gprz_memp(*entry_ebx)
    *eax_1 += eax_1.b
    void var_1
    esp = &var_1
    *arg6 = *arg5
    arg6 = &arg6[1]
    arg5 += 2
else
    arg1:1.b += arg3:1.b
    arg1.b |= 0x4a
    *(arg3 + 0x4a0e) += (arg2 - 1):1.b
    *arg1 += arg1.b
    *(arg4 + 0xf) += arg1.b
    arg2 -= 2
    arg1:1.b += arg1.b
    eax_1 = &arg1[*arg1]
    arg7 += arg3.b

eax_1.b *= 2
*arg2
eax_1.b &= 0xd5
*eax_1 += arg3:1.b
eax_1.b = *(entry_ebx + eax_1)
eax_1:1.b += eax_1.b
*(eax_1 + 1) += (eax_1 + 1):1.b
*(esp + arg6) += entry_ebx.b
*(((eax_1 + 1) | 0x3c000047) + 0x300046d9) += arg2.b
*arg6 += arg3.b
*(((eax_1 + 1) | 0x3c000047) - 0x35a3b8df) += (arg3 + 1).b
*(arg5 + 3)
entry_ebx.b = 0
char temp1 = (((eax_1 + 1) | 0x3c000047) - 0x21a3ffb8).b
char temp2 = (((eax_1 + 1) | 0x3c000047) - 0x21a3ffb8).b
void* eax_6
eax_6.b = (((eax_1 + 1) | 0x3c000047) - 0x21a3ffb8).b * 2
char* esi_7
void* edi

if (temp1 != neg.b(temp2))
    *arg6 = *(arg5 + 4)
    edi = &arg6[1]
    esi_7 = arg5 + 5
    
    if (temp1 != neg.b(temp2))
        goto label_4a0c93
    
    goto label_4a0c4b

eax_6.b = eax_6.b
*arg2
entry_ebx:1.b += eax_6:1.b
*(arg6 + arg5 + 5 + 0x36d00042) += arg2:1.b
edi = &arg6[1]
*(eax_6 + 0x540046d3) = *(eax_6 + 0x540046d3)
*arg4 += 1
*(esp - 4) = eax_6
*(esp - 8) = arg3 + 1
*(esp - 0xc) = arg2
*(esp - 0x10) = entry_ebx
*(esp - 0x14) = esp - 0x10
*(esp - 0x18) = arg4
*(esp - 0x1c) = arg5 + 5
*(esp - 0x20) = edi
esp -= 0x20
*(eax_6 - 0x2b53ba52) += entry_ebx:1.b
*entry_ebx += arg2:1.b
esi_7 = arg5 + 7
*(esi_7 * 9 + 0x45) = *(esi_7 * 9 + 0x45)
eax_6.b = (eax_6 + 0x4ac0046).b + entry_ebx:1.b
eax_6:1.b += entry_ebx:1.b
*eax_6 += (arg3 + 1):1.b
int32_t eflags
eax_6.b = __in_al_immb(0x46, eflags)
*(eax_6 - 0x5f) += arg2:1.b
*(entry_ebx + esi_7 + 0x75a40047) = *(entry_ebx + esi_7 + 0x75a40047)
arg4 += 5
label_4a0c4b:
arg2[arg4 << 1] += arg2:1.b
void* ebp_4 = arg4 + 1
char temp3_1 = *eax_6
*eax_6 += arg2:1.b

if (temp3_1 != neg.b(arg2:1.b) && temp3_1 + arg2:1.b u>= temp3_1)
    eax_6:1.b += entry_ebx.b
else
    esi_7[0x46] += eax_6.b
    *eax_6 += eax_6.b
    void* eax_7 = __in_oeax_immb(0x46, eflags)
    *(eax_7 + (edi << 1) + 0x45) += (arg3 + 1):1.b
    *(eax_7 - 0x19) += eax_7.b
    eax_6 = *0xf6b00045
    *(eax_6 - 9) += arg2:1.b
    arg4 = ebp_4 + 2
    arg2[(&esi_7[1] << 3) + 0x45] += eax_6:1.b
    *(edi + (&esi_7[1] << 3) + 0x45) += arg2.b
    *(eax_6 + 0x140046d2) += (arg3 + 1).b
    __out_dx_oeax(arg2.w, eax_6, eflags)
    esi_7 = &esi_7[2]
    *(edi * 5 + 0x2e40045) += eax_6:1.b
    *(arg2 + arg3 + 1) += (arg3 + 1):1.b
    *eax_6 += entry_ebx:1.b
    *(edi + 2) |= eax_6.b
label_4a0c93:
    *(eax_6 - 0x40) += eax_6:1.b
    ebp_4 = arg4 + 2
    *(eax_6 - 0x23ffb8f5) += (arg3 + 1):1.b

eax_6.b |= 0x47
*(eax_6 + 0x400045be) += entry_ebx.b
char* eax_8 = eax_6 | 0xf89c0046
*(esp + arg2) += arg2.b
*(esp + arg3 + 1 - 0xaf3ffba) += arg2:1.b
*(esi_7 + arg3 + 1) += eax_8.b
*(&esi_7[1] + ebp_4 + 2 - 0x3397ffb9) += arg2.b
*eax_8 += entry_ebx.b
undefined
