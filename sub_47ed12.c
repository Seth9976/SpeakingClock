// 函数: sub_47ed12
// 地址: 0x47ed12
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

char* eax = arg6
void arg_20
void* esp = &arg_20
bool z

if (z)
    goto label_47ed28

*eax += eax.b
*arg5 += eax.b
*eax += eax.b
eax[arg4 + 0x40040] += arg3:1.b
char temp0_1 = *eax
*eax += eax.b
int32_t eflags

if (temp0_1 + eax.b s< 0)
    eax.b = eax.b
    *eax += eax.b
    *eax = &eax[*eax]
    *eax += eax.b
    esp = 0x4004010
label_47ed28:
    *eax += eax.b
    eax[0x47ed78] += arg4.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    char temp0_2
    char temp1_1
    temp0_2, temp1_1, eflags = __aam_immb(0xee, eax.b)
    eax.b = temp0_2
    eax:1.b = temp1_1
else
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    eax:1.b += arg4.b
    __out_dx_al(arg4.w, eax.b, eflags)

*eax += eax.b
*eax += eax.b
*eax += eax.b
*eax += eax.b
eax[0xbe0047ee] += eax.b
__out_dx_al(arg4.w, eax.b, eflags)
eax.b += eax:1.b
eax.b += *eax
eax.b += arg3:1.b
void* ebp_1 = *esp
eax.b *= 2
*arg4
void* eax_1 = eax ^ *arg4
char* edi_3
int16_t es
edi_3, es = __les_gprz_memp(*arg1)
*(eax_1 + 0x43b2) += arg4.b
*(0xfc00403e + edi_3) += arg3.b + 1
*(arg1 + (arg5 << 1) + 0x48) += (eax_1 + 2):1.b
*(eax_1 + 2) += arg4:1.b
*edi_3 += arg5.b
*(eax_1 - 0x41c3ffb8) += (eax_1 - 0x41c3ffb8).b
*(eax_1 - 0x41c3ffb8) = *(eax_1 - 0x41c3ffb8)
void* eax_4
eax_4.b = (eax_1 - 0x41c3ffb8).b + 0x43
*arg4
int32_t eflags_1
char temp0_3
char temp1_2
temp0_3, temp1_2, eflags_1 = __aaa(eax_4.b, eax_4:1.b, eflags)
eax_4.b = temp0_3
eax_4:1.b = temp1_2
eax_4.b += eax_4:1.b
*(arg4 + 1)
eax_4.b ^= 0x4d
*(edi_3 * 9 + 0x45) += (arg4 + 1).b
*(eax_4 + 4) += (eax_4 - 1):1.b
*(eax_4 + 0x1cb8427c) += (&arg5[1]):1.b
void* eax_5
eax_5.b = (eax_4 - 1).b + (arg4 + 1).b
eax_5.b += (arg4 + 1):1.b
*((arg1 + 1) * 9 + 0x45) += 0x43
eax_5.b = eax_5.b
eax_5:1.b = eax_5:1.b
arg5[0x46] += eax_5.b
*(eax_5 - 0x5f) += (arg4 + 1):1.b
*eax_5 = *eax_5
*0xb4004233 = 0x45
arg5[((ebp_1 + 9) << 2) + 0x44] += 0x43
*(arg4 + 1 + ((ebp_1 + 9) << 1)) += (arg4 + 1):1.b
char temp1_3 = *eax_5
*eax_5 += (arg4 + 1):1.b

if (temp1_3 != neg.b((arg4 + 1):1.b) && temp1_3 + (arg4 + 1):1.b u>= temp1_3)
    trap(0xd)

char temp2 = *(eax_5 - 0xfffb9f2)
*(eax_5 - 0xfffb9f2) += eax_5.b

if (temp2 + eax_5.b s< 0)
    jump(0x47edeb)

char* eax_6 = eax_5 | 0xf89c0046
*eax_6 += (&arg5[1]):1.b
*(ebp_1 + 0xb) = rol.d(*(ebp_1 + 0xb), 1)
eax_6:1.b = 0xc
*(((arg1 + 2) << 3) + 0xe040045) += (&arg5[1]).b
eax_6[edi_3 << 3] += eax_6.b
*((arg4 + 1) * 3 + 0x48) += 0xc
*eax_6 += (arg4 + 1):1.b
*0x4000484c = 0xb8540043
eax_6[0x52] += 0x43
*(eax_6 - 2) += (eax_6 - 2).b
*0x40004848 = 0x4000484c
void* eax_9
eax_9:1.b = (eax_6 - 3):1.b + 0x43
*0x40004844 = 0x40004848
*(ebp_1 + 0xc + ((arg4 + 1) << 1) + 0x4ec00048) += (&arg5[1]).b
*(((arg4 + 1) << 1) + 0xb854008b) = *(((arg4 + 1) << 1) + 0xb854008b)
*((arg4 + 1) * 3 + 0x52e40048) += (eax_9 - 2).b
void* eax_12
eax_12.b = (eax_9 - 3).b
*0x40004844
*(ebp_1 + 0xc + ((arg4 + 1) << 1) + 0xa0048) += (arg4 + 1):1.b
undefined
