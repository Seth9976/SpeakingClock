// 函数: sub_417d20
// 地址: 0x417d20
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp1 = *arg1
*arg1 += arg1.b
int16_t entry_ebx
*(arg4 + 0x41) = adc.b(*(arg4 + 0x41), entry_ebx:1.b, temp1 + arg1.b u< temp1)
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp2 = *arg1
*arg1 += arg1.b
void* ecx_4
int32_t eflags

if (temp2 s<= neg.b(arg1.b))
    void* ecx
    
    if (temp2 == neg.b(arg1.b))
        while (true)
            arg3 += 1
        label_417d47:
            arg1[0xbc00403e] += arg2:1.b
            void* eax
            eax.b = (&arg1[1]).b * 2
            void* eax_1
            eax_1:1.b = (eax + 1):1.b + (eax + 1).b
            *(eax_1 + 0x403f) += entry_ebx:1.b
            *(&__return_addr + arg5) += entry_ebx.b
            *(eax_1 - 0xfffbe3d) += (eax_1 + 2).b
            *arg4 - *arg5
            arg4 += 4
            arg3 += 1
            void* eax_3
            eax_3.b = (eax_1 + 2).b + arg3:1.b
            entry_ebx.b = 0x41
            eax_3.b *= 2
            arg2.b = 0x41
            char temp5_1 = *eax_3
            *eax_3 += entry_ebx:1.b
            int32_t eax_4
            int16_t es_1
            eax_4, es_1 = __les_gprz_memp(*arg3)
            uint8_t temp0_2
            temp0_2, arg5 = __insb(&arg5[4], arg2, eflags)
            *arg5 = temp0_2
            int16_t es_2
            arg1, es_2 = __les_gprz_memp(*arg3)
            
            if (not(add_overflow(temp5_1, entry_ebx:1.b)))
                break
            
            *arg1 += arg1.b
            arg1.b = __in_al_immb(0x7b, eflags)
        
        ecx = arg3 + 1
        void arg_41
        *(&arg_41 + (arg1 << 3)) += arg2:1.b
    else
        ecx = arg3 + 1
    
    arg5[(arg4 << 2) - 0x3a13ffbf] += ecx:1.b
    arg1[0xffffffc6] += (ecx + 1).b
    arg5[arg1 << 3] += entry_ebx.b
    *(arg4 + (arg5 << 2) + 0x41) += entry_ebx:1.b
    arg1[0xffffffc7] += entry_ebx.b
    ecx_4 = ecx + 4
    arg1.b += entry_ebx.b
    *ecx_4 = sub_41c1dc
    arg1.b = __in_al_dx(arg2, eflags)
else
    *arg1 += entry_ebx:1.b
    *arg1 += arg1.b
    arg1:1.b *= 2
    bool p_1 = unimplemented  {add ah, ah}
    
    if (p_1)
        goto label_417d47
    
    arg1.b = __in_al_dx(arg2, eflags)
    int32_t eax_5
    int16_t ds_1
    eax_5, ds_1 = __lds_gprz_memp(*arg3)
    *arg3 = 0x1c
    *arg3 = sub_41be7c
    arg1 = __return_addr
    *arg3 = sub_41c7d8
    ecx_4 = arg3 + 1
    arg1:1.b += ecx_4:1.b
*ecx_4 = rol.d(*ecx_4, 8)
arg2.b = 0x41
arg1[0xc80041c2] += ecx_4.b
