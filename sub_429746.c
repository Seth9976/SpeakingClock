// 函数: sub_429746
// 地址: 0x429746
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*(arg3 + 0x67)
char* esp_1 = *(arg3 + 0x67) * 0x736f7243
bool c = unimplemented  {imul esp, dword [ecx+0x67], 0x736f7243}
void* entry_ebx
void* ebx_1

if (c)
    void* temp2_1 = arg5
    arg5 += 1
    bool o_1 = add_overflow(temp2_1, 1)
    int32_t* eax_5
    
    if (c)
    label_4297b7:
        char ecx_4
        int32_t edx_2
        int32_t ebp
        eax_5, edx_2, ecx_4 = (*(arg4 + (ebp << 2)))()
        char temp5_1 = *arg5
        *arg5 += ecx_4
        *(esp_1 - 4) = esp_1
        o_1 = add_overflow(arg5, 1)
        
        if (temp5_1 + ecx_4 u< temp5_1)
            char temp8_1 = *(arg5 + 0x73)
            *(arg5 + 0x73) |= eax_5.b
            *(esp_1 - 4)
            *esp_1
            *(esp_1 + 4)
            ebx_1 = *(esp_1 + 0xc)
            *(esp_1 + 0x10)
            *(esp_1 + 0x14)
            *(esp_1 + 0x18)
            *(ebx_1 + 0x73)
            *(ebx_1 + 0x73)
            bool o_4 = unimplemented  {imul esp, dword [ebx+0x73], 0xffff0001}
            
            if ((temp8_1 | eax_5.b) s< 0 != o_4)
                jump(0x4297ca)
            
            jump(&data_429830:2)
    else
        if (not(o_1))
            esp_1 = *(entry_ebx + 0x73) * 0x4297a890
            goto label_42975f
        
        *esp_1
        *(esp_1 + 4)
        *(esp_1 + 8)
        *(esp_1 + 0x10)
        *(esp_1 + 0x14)
        *(esp_1 + 0x18)
        eax_5 = *(esp_1 + 0x1c)
    
    if (o_1)
        *eax_5 += eax_5
        undefined
    
    jump("icsObject")

arg2 += 1
label_42975f:
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg1.b += arg2.b
*arg5 += arg5.b
*arg5 += arg5.b
*arg5 += arg5.b
*arg5 += arg5.b
arg1[((arg2 + 1) << 2) - 0x6843ffbe] += (arg2 + 1):1.b
*arg5 += entry_ebx.b
*arg5 += arg5.b
char temp3_1 = arg5.b
char temp4_1 = arg5.b
void* eax
eax.b = arg5.b * 2

if (temp3_1 == neg.b(temp4_1) || temp3_1 + temp4_1 u< temp3_1)
    *(eax - 0x43ffbfc2) += (arg2 + 2):1.b
    void* eax_1
    eax_1.b = (eax + 1).b * 2
    void* eax_2
    eax_2:1.b = (eax_1 + 1):1.b + (eax_1 + 1).b
    *(eax_2 + 0x403f) += entry_ebx:1.b
    *(esp_1 + arg1) += entry_ebx.b
    int16_t eax_4
    eax_4.b = ((eax_2 + 1).w + 1).b + ((eax_2 + 1).w + 1):1.b
    *arg4 - *arg1
    int32_t esi = arg4 + 1
    void* edi_1 = &arg1[1]
    eax_4.b += (arg2 + 2):1.b
    *esi - *edi_1
    int32_t esi_1 = esi + 4
    void* edi_2 = edi_1 + 4
    eax_4.b += entry_ebx:1.b
    *esi_1 - *edi_2
    arg4 = esi_1 + 4
    arg5 = edi_2 + 4
    *arg5 += (arg3 + 3).b
    *(arg3 + 4) += eax_4.b
    void* ecx_3
    ecx_3:1.b = (arg3 + 4):1.b + entry_ebx:1.b
    goto label_4297b7

*(esp_1 - 4) = 0x65
int32_t eflags_1
int16_t temp0_2
temp0_2, eflags_1 = __arpl_memw_gpr16(*(eax + ((arg2 + 2) << 3) - 0x69), arg4.w)
*(eax + ((arg2 + 2) << 3) - 0x69) = temp0_2
char temp7_1 = *arg1
*arg1 += eax.b
__andps_xmmxud_memxud(arg6, *(arg1 + 0x72))
void* edi_5 = *(esp_1 - 4)
char* esi_3 = *esp_1
void* ebp_2 = *(esp_1 + 4)
ebx_1 = *(esp_1 + 0xc)
void* edx_5 = *(esp_1 + 0x10)
void* ecx_6 = *(esp_1 + 0x14)
void* eax_6 = *(esp_1 + 0x18)
void* edx_6
void* esp_6
void* edi_6

if (add_overflow(temp7_1, eax.b))
    eax_6.b = *esi_3
    esi_3 = &esi_3[1]
    int32_t eax_8 = sx.d(eax_6.w)
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *eax_8 += eax_8.b
    *(edx_5 - 0x5dffbd67) += ebx_1.b
    void* eax_9 = sx.d(eax_8.w)
    *(eax_9 * 2) += eax_9:1.b
    *eax_9 += eax_9.b
    esp_6 = *(esp_1 + 0x1c)
    edi_6 = eax_9
    eax_6 = edi_5
    edx_6 = edx_5 + 3
    goto label_42985b

esp_6 = *(ebx_1 + 0x73) * 0x656a624f
int32_t eflags_2
int16_t temp0_3
temp0_3, eflags_2 = __arpl_memw_gpr16(*(eax_6 + (ebp_2 << 2) - 0x69), esi_3.w)
*(eax_6 + (ebp_2 << 2) - 0x69) = temp0_3
edx_6 = edx_5 + 1
*(eax_6 + (edi_5 << 1)) += edx_6:1.b
*eax_6 += eax_6.b
char temp9_1 = *eax_6
*eax_6 += (ecx_6 + 1).b
edi_6 = edi_5 + 1

if (temp9_1 + (ecx_6 + 1).b u>= temp9_1)
    if (add_overflow(edi_5, 1))
        jump(0x429859)
    
    jump(0x4297f1)

*0x24004298 = eax_6.b
char i

do
    *eax_6 += eax_6.b
    *(edi_6 + (edx_6 << 2) + 0x42) += ebx_1.b
label_42985b:
    *(eax_6 - 0x43ffbfc2) += edx_6:1.b
    void* eax_10
    eax_10.b = (eax_6 + 1).b * 2
    void* eax_11
    eax_11:1.b = (eax_10 + 1):1.b + (eax_10 + 1).b
    *(eax_11 + 0x403f) += ebx_1:1.b
    *(esp_6 + edi_6) += ebx_1.b
    *(eax_11 + 2) += edx_6:1.b
    ecx_6.b = 0x42
    void* eax_7
    eax_7.b = (eax_11 + 2).b + edx_6:1.b
    *esi_3 - *edi_6
    void* esi_4 = &esi_3[4]
    void* edi_8 = edi_6 + 4
    eax_7.b += ebx_1:1.b
    *esi_4 - *edi_8
    esi_3 = esi_4 + 4
    char* ecx_7 = ecx_6 + 2
    ecx_7[(esi_3 << 2) + 0x42] += edx_6:1.b
    *esi_3 += ecx_7.b
    *eax_7 += eax_7.b
    *eax_7 += eax_7.b
    *ecx_7 += eax_7.b
    *eax_7 += eax_7.b
    eax_7.b += ebx_1:1.b
    char* temp0_5 = edi_8 + 4
    edi_6 = eax_7
    *temp0_5 += temp0_5:1.b
    *temp0_5 += temp0_5.b
    *ecx_7 += temp0_5.b
    ecx_7:1.b += ebx_1:1.b
    void* edx_10
    eax_6, edx_10, ecx_6 = (*(temp0_5 - 0x4f))()
    edx_6 = edx_10 + 1
    i = *0x6e6f4654
    *0x6e6f4654 += eax_6.b
while (i == neg.b(eax_6.b))
int32_t eax_14 = sx.d(eax_6.w)
*edi_6 += eax_14.b

if (eax_14 == 0x9190b9ac)
    jump(sub_429834+0xfc)

jump(sub_429834+0x80)
