// 函数: sub_4413ed
// 地址: 0x4413ed
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

int32_t temp2 = *(arg1 * 2 + 7)
int16_t es
uint32_t var_4 = zx.d(es)
uint32_t* var_8 = &var_4
int32_t eflags
int16_t* edi
int16_t temp0
temp0, edi = __insd(arg3, arg2, eflags)
*edi = temp0
uint32_t* edi_1 = var_8
uint32_t esi = var_4
char* ebx = arg4
char* edx = arg5
int32_t* ecx = arg6
void arg_18
void* esp = &arg_18
void* arg_14
bool c
char* eax_2 = adc.d(arg_14 + 1, *((arg_14 + 1) * 2 - 0x10), 
    adc.d(arg1, temp2, c) u< arg1 || (c && adc.d(arg1, temp2, c) == arg1))
*edi_1 += ecx:1.b
char temp3 = *eax_2
*eax_2 += ecx.b
bool c_3

if (__return_addr + 2 s< 0)
    eax_2.b |= 0x2d
    void arg_19
    esp = &arg_19
    *ecx += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 = *eax_2
    char temp5_1 = *eax_2
    *eax_2 += eax_2.b
    c_3 = temp5_1 + eax_2.b u< temp5_1
else
    char* temp6_1 = ebx
    ebx = &ebx[1]
    
    if (temp6_1 != 0xffffffff)
        uint8_t* edi_2
        uint8_t temp0_1
        temp0_1, edi_2 = __insb(edi_1, edx.w, eflags)
        *edi_2 = temp0_1
        void* eax_4
        void* esp_3
        int16_t ebp_3
        
        if (temp3 + ecx.b u>= temp3)
            ebx:1.b *= 2
            arg_14 = __return_addr + 2
            ebp_3 = &arg_14
            void var_4554
            esp_3 = &var_4554
            eax_4.b = __in_al_immb(0x69, eflags)
        else
            *ebx += ebx.b
            arg_14 = &arg_18
            char* eax_3 = *(__return_addr + 2)
            *eax_3 += eax_3.b
            *eax_3 += eax_3.b
            *eax_3 += eax_3.b
            *eax_3 = *eax_3
            *eax_3 += eax_3.b
            uint8_t** esp_1 = *(edi_2 + 0x6e) * 0x451d68
            edi_2 = *esp_1
            esi = esp_1[1]
            ebp_3 = (esp_1[2]).w
            ebx = esp_1[4]
            edx = esp_1[5]
            ecx = esp_1[6]
            char* eax_5 = esp_1[7]
            *eax_5 += eax_5.b
            eax_4 = eax_5 - 1
            esp_1[7] = 0x69e40045
            esp_3 = &esp_1[7]
        
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *ebx = *ebx
        *eax_4 += eax_4.b
        int16_t cs
        *(esp_3 - 4) = zx.d(cs)
        uint8_t temp13 = *edi_2
        *edi_2 += eax_4.b
        __outsb(edx.w, *esi, esi, eflags)
        int32_t eflags_1
        int16_t temp0_3
        temp0_3, eflags_1 = __arpl_memw_gpr16(*(eax_4 + 0x6f), ebp_3 + 1)
        *(eax_4 + 0x6f) = temp0_3
        
        if (temp13 + eax_4.b u>= temp13)
            jump(0x44144f)
        
        *eax_4 += eax_4.b
        *(ecx + 1) += 1
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        eax_4:1.b ^= 0xff
        undefined
    
    eax_2 -= 0x10044
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    char temp9_1 = *eax_2
    *eax_2 += eax_2.b
    c_3 = temp9_1 + eax_2.b u< temp9_1

char temp7 = *eax_2
*eax_2 = adc.b(temp7, eax_2.b, c_3)
*(esp - 4) = zx.d(es)
void* ebx_1 = &ebx[1]
uint16_t* gsbase
uint16_t* esi_2 = __outsb(edx.w, *(gsbase + esi), esi, eflags)
void* esp_7

if (ebx == 0xffffffff)
    char temp10_1 = *eax_2
    *eax_2 += ecx.b
    esp_7 = esp - 3
    
    if (temp10_1 + ecx.b u>= temp10_1)
        *esp_7
        *eax_2 += eax_2.b
        jump(*(eax_2 * 2))
    
    *esi_2 += edx.b
else
    if (adc.b(temp7, eax_2.b, c_3) u>= temp7 && (not(c_3) || adc.b(temp7, eax_2.b, c_3) != temp7))
        int16_t ds
        *(esp - 8) = zx.d(ds)
        *(eax_2 * 2) += edx:1.b
        undefined
    
    *eax_2 += eax_2.b
    *eax_2 = *eax_2
    char temp12_1 = eax_2[0x430b0011]
    eax_2[0x430b0011] += eax_2.b
    bool c_5 = temp12_1 + eax_2.b u< temp12_1
    uint16_t* esi_3 = __outsd(edx.w, *esi_2, esi_2, eflags)
    __outsb(edx.w, *esi_3, esi_3, eflags)
    
    if (c_5)
        if (c_5)
            jump(0x441516)
        
        jump("ints")
    
    *eax_2 += edx.b
    *(esp - 8) = 0xd4fe0000
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *ecx = *ecx
    *eax_2 += eax_2.b
    edi_1 = *(esp - 8)
    esi_2 = *(esp - 4)
    void* ebp_7 = *esp
    ebx_1 = *(esp + 8)
    edx = *(esp + 0xc)
    ecx = *(esp + 0x10)
    char* eax_6 = *(esp + 0x14)
    __bound_gprv_mema32(ebp_7, *(ebp_7 + 0x64))
    *eax_6 += edx.b
    eax_2 = &eax_6[1]
    edx[0xaaff0001] += ecx:1.b
    *eax_2 = &eax_2[*eax_2]
    *ecx += 1
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    *eax_2 = *eax_2
    *eax_2 += eax_2.b
    int16_t ss
    *(esp + 0x14) = zx.d(ss)
    esp_7 = esp + 0x14

*edx += edx.b
int32_t esi_5 = __outsb(edx.w, *esi_2, esi_2, eflags)
int32_t eflags_2
int16_t temp0_4
temp0_4, eflags_2 = __arpl_memw_gpr16(*(edx + 0x65), esi_5.w)
*(edx + 0x65) = temp0_4
int16_t* edi_3
int16_t temp0_5
temp0_5, edi_3 = __insd(edi_1, edx.w, eflags_2)
*edi_3 = temp0_5
__outsb(edx.w, *(gsbase + esi_5), esi_5, eflags_2)

if (ecx == 1)
    *eax_2 += eax_2.b
    *eax_2 += eax_2.b
    char temp16 = eax_2[0x80000000]
    eax_2[0x80000000] += eax_2.b
    *eax_2 = sbb.d(*eax_2, eax_2, temp16 + eax_2.b u< temp16)
    *(eax_2 + 0x6f)
    *(eax_2 + 0x6f) |= edx
    jump("pMenu")

uint8_t* edi_4
uint8_t temp0_6
temp0_6, edi_4 = __insb(edi_3, edx.w, eflags_2)
*edi_4 = temp0_6
*(ebx_1 + 0x70)
*(ebx_1 + 0x70)
bool c_7 = unimplemented  {imul esi, dword [ebx+0x70], 0x79616c}
*eax_2 = adc.b(*eax_2, eax_2.b, c_7)
*eax_2
ebx_1:1.b *= 2

if (esp_7 s>= 0)
    jump(0x4415c3)

jump(0x44157e)
