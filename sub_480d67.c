// 函数: sub_480d67
// 地址: 0x480d67
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

int32_t* entry_ebx
char temp1 = *(entry_ebx + 0x79)
*(entry_ebx + 0x79) += arg2
void* esp

if (temp1 + arg2 u>= temp1)
    *arg1 += arg1.b
label_480dc8:
    
    if (entry_ebx[0x9a] != 0)
        (*(*entry_ebx[0x9c] + 8))()
        entry_ebx[0x99]
        (*(*entry_ebx + 0xe4))()
        sub_403c68(entry_ebx[0x9a])
        entry_ebx[0x9a] = 0
else
    void arg_20
    esp = &arg_20
    __bound_gprv_mema32(arg8, *(arg5 + 0x6f))
    int32_t eflags
    uint16_t* esi_2 = __outsb(arg6.w, *arg3, arg3, eflags)
    
    if (temp1 != neg.b(arg2))
        __outsd(arg6.w, *esi_2, esi_2, eflags)
        uint8_t* edi_2
        uint8_t temp0_1
        temp0_1, edi_2 = __insb(__return_addr, arg6.w, eflags)
        *edi_2 = temp0_1
        *arg6
        *(arg5 + 0x56) += arg6.b
        entry_ebx = arg8
        sub_45baac(entry_ebx)
        void* esi_5 = entry_ebx[0x97]
        
        if (esi_5 != 0 && sub_466ad8(esi_5).b != 0)
            sub_458ac8(entry_ebx, sub_466cac(entry_ebx[0x97]))
            esp = &arg_20
        
        if (entry_ebx[0x9d] != 0)
            sub_4813a0(entry_ebx)
        
        goto label_480dc8
    
    int32_t* eax
    eax.b = __in_al_immb(0, eflags)
    *eax += eax.b
    sub_403c68(arg5[0x9a])
    arg5[0x9a] = 0

*esp
*(esp + 4)
