// 函数: sub_44a4ee
// 地址: 0x44a4ee
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg5 += arg1.b
int16_t cs
uint32_t var_3 = zx.d(cs)
uint32_t* var_7 = &var_3
uint32_t** esp = &var_7
void* ebp = arg4 - 1
int32_t eflags
uint16_t* gsbase
uint16_t* esi = __outsb(arg2.w, *(gsbase + arg5), arg5, eflags)
void* eax_3
int16_t entry_ebx
int16_t es

if (arg4 != 1)
    void* eax_1
    eax_1:1.b = (&arg1[1]):1.b + entry_ebx:1.b
    void* eax_2 = eax_1 ^ *arg2
    arg6, es = __les_gprz_memp(*esi)
    eax_3 = eax_2 + 1
    goto label_44a543

esi = __outsb(arg2.w, *esi, esi, eflags)
ebp = *(ebp + 0x61) * 0x6e6f6974
arg7 += arg1
*(ebp + 0x44) += arg2.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg1[0x44a5] += arg3:1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg1[0x780044a5] += entry_ebx.b
*arg1 += arg1.b
*arg1 += arg3:1.b
char* eax = *0x3ac00044
void* edx = arg2 + 1

while (true)
    *(esi + arg6 + 0x33fc0040) += entry_ebx:1.b
    arg2 = edx + 1
    eax:1.b += eax.b
    eax_3 = &eax[1]
label_44a543:
    *(eax_3 + 0x403e) += entry_ebx:1.b
    *(esp + arg6) += entry_ebx.b
    *(eax_3 - 0xfffbaf1) += (eax_3 + 1):1.b
    *esi - *arg6
    void* esi_1 = &esi[2]
    char* edi = arg6 + 4
    eax:1.b = (eax_3 + 1):1.b + (eax_3 + 1).b
    *edi += (&arg3[1]).b
    arg3 = &arg3[2]
    *eax += arg3.b
    eax.b += *ebp
    *edi = *esi_1
    arg6 = &edi[1]
    void* esi_2 = esi_1 + 1
    eax.b += *ebp
    eax.b = *esi_2
    void* esi_3 = esi_2 + 1
    int32_t eflags_1
    char temp0_1
    char temp1_1
    temp0_1, temp1_1, eflags_1 = __aaa(eax.b, eax:1.b, eflags)
    eax.b = temp0_1
    eax:1.b = temp1_1
    *(eax + arg6 + 0x3ad80042) += eax:1.b
    *(arg6 + esi_3 + 0x37b40042) += entry_ebx:1.b
    edx = arg2 + 4
    eax.b += eax:1.b
    *edx
    eax.b -= 0xe
    eax.b += edx:1.b
    int32_t temp2_1 = *(ebp + 1)
    *(ebp + 1) = &eax[*(ebp + 1)]
    eax.b = sbb.b(eax.b, 0xf8, &eax[temp2_1] u< temp2_1)
    *eax += eax:1.b
    eax.b += *(ebp + 1)
    char temp0_2
    char temp1_2
    temp0_2, temp1_2, eflags = __aam_immb(0xe, eax.b)
    eax.b = temp0_2
    eax:1.b = temp1_2
    ebp += 2
    char temp3_1 = eax[0xa00450f]
    eax[0xa00450f] += edx.b
    bool o_1 = add_overflow(temp3_1, edx.b)
    *(esp - 3) = esp + 1
    *(esp - 7) = eax
    esp -= 7
    esi = __outsd(edx.w, *esi_3, esi_3, eflags)
    void* eax_7
    bool z_3
    bool s_1
    bool o_4
    
    if (o_1)
        *(arg6 + eax + 0x45) += eax.b
        *(arg6 + eax + 0x45) += edx.b
        *arg3 += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        *eax += eax.b
        
        if (eax == 0x8abeef00)
            eax_7 = &eax[0x754110ff]
            z_3 = eax == 0x8abeef01
            s_1 = &eax[0x754110ff] s< 0
            o_4 = add_overflow(&eax[0x75411100], 0xffffffff)
            uint8_t temp0_4
            temp0_4, arg6 = __insb(arg6, edx.w, eflags)
            *arg6 = temp0_4
            goto label_44a6a1
        
        int32_t ebp_4 = *(esi + 0x65) * 0x75646552
        int16_t temp0_3
        temp0_3, eflags = __arpl_memw_gpr16(*(arg3 + (ebp_4 << 1) + 0x6f), esi.w)
        *(arg3 + (ebp_4 << 1) + 0x6f) = temp0_3
        __outsb(edx.w, *esi, esi, eflags)
        eax[0x75411100] += edx.b
        *arg3 += ((&eax[0x75411100]).w + 1):1.b
        arg6 = *(esp - 1)
        esi = *(esp + 3)
        ebp = *(esp + 7)
        entry_ebx = (*(esp + 0xf)).w
        edx = *(esp + 0x13)
        void* ecx_1 = *(esp + 0x17)
        eax = *(esp + 0x1b)
        *eax += eax.b
        *ecx_1 += 1
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *ecx_1 = *ecx_1
        *eax += eax.b
        *(esp + 0x1b) = zx.d(es)
        esp += 0x1b
        *ecx_1 += ecx_1.b
        arg3 = ecx_1 + 1
        bool o_2 = add_overflow(ecx_1, 1)
        
        if (ecx_1 != 0xffffffff)
            eax = *eax * 0x69ff00
        else
            uint16_t* esi_5 = __outsd(edx.w, *esi, esi, eflags)
            *(esp - 4) = eax
            esp -= 4
            esi = __outsd(edx.w, *esi_5, esi_5, eflags)
            
            if (not(o_2))
                if (not(o_2))
                    return sub_44a661(eax, edx.w, arg3, esi) __tailcall
                
                break
        
        entry_ebx:1.b *= 2
        *eax = &eax[*eax]
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        eax.b |= *eax
        eax_7 = eax | 0x756e654d
        arg3 = &arg3[1]
        goto label_44a6ea
    
    if (o_1)
    label_44a5ed:
        *eax += eax:1.b
        *eax += edx:1.b
        *(esp + 2)
        *arg3 += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax += eax.b
        *eax = *eax
        *eax += eax.b
        eax.b = eax.b
        char* eax_4 = eax | *(arg3 + 0x75)
        
        if (eax_4 != 0)
            char* temp8_1 = eax_4
            eax_4 -= 1
            esi = __outsd(edx.w, *esi, esi, eflags)
            
            if (temp8_1 != 1)
                if (temp8_1 - 1 s>= 0)
                    jump(0x44a683)
                
                jump(&data_44a610)
        
        esp[1].w
        *eax_4 += arg3.b
        edx += 1
        *(arg3 + ((ebp + 2) << 1) + 0x4d)
        bool c_2 = unimplemented  {imul eax, dword [ecx+ebp*2+0x4d], 0xc065646f}
        bool o_3 = unimplemented  {imul eax, dword [ecx+ebp*2+0x4d], 0xc065646f}
        
        if (o_3)
            if (not(c_2))
                jump(0x44a6b7)
            
            jump(0x44a6cb)
        
        eax_7.b = (*(arg3 + ((ebp + 2) << 1) + 0x4d) * 0xc065646f).b + arg3:1.b
        *(esp + 2) = zx.d(cs)
        eax_7.b += edx:1.b
        *(esp - 2) = zx.d(cs)
        esp -= 2
        ebp += 4
        *arg3 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 += eax_7.b
        *eax_7 = *eax_7
        *eax_7 += eax_7.b
        *eax_7 |= eax_7.b
        char* temp11_1 = arg3
        int32_t temp12_1 = *(eax_7 + 0x65)
        arg3 |= *(eax_7 + 0x65)
        z_3 = (temp11_1 | temp12_1) == 0
        s_1 = (temp11_1 | temp12_1) s< 0
        o_4 = false
        uint8_t temp0_5
        temp0_5, arg6 = __insb(arg6, edx.w, eflags)
        *arg6 = temp0_5
    label_44a6a1:
        uint16_t* esi_7
        
        if (o_4)
            esi = __outsb(edx.w, *(gsbase + esi), esi, eflags)
            
            if (not(z_3))
                *eax_7 += eax_7.b
                char temp13 = *(eax_7 * 2)
                *(eax_7 * 2) += arg3.b
                *(esp - 4) = zx.d(cs)
                *(esp - 8) = eax_7
                int16_t* edi_1 = *(esp - 8)
                uint16_t* esi_9 = *(esp - 4)
                *esp
                esp[2]
                int16_t edx_4 = (esp[3]).w
                esp[4]
                void* eax_9 = esp[5]
                
                if (temp13 + arg3.b u>= temp13)
                    __outsb(edx_4, *esi_9, esi_9, eflags)
                    
                    if (temp13 == neg.b(arg3.b))
                        jump(0x44a77a)
                    
                    jump("iDiMode")
                
                *(eax_9 - 0x80000000) += eax_9.b
                int0_t ldtr
                *edi_1 = __sldt_memw(ldtr)
                uint16_t* esi_12 = __outsb(edx_4, *esi_9, esi_9, eflags)
                esp[5] = eax_9
                __outsd(edx_4, *esi_12, esi_12, eflags)
                
                if (add_overflow(edi_1, 0xffffffff))
                    jump(0x44a81e)
                
                jump(0x44a7a9)
            
        label_44a6ea:
            esi_7 = __outsb(edx.w, *esi, esi, eflags)
            *(ebp + 0x61)
            *eax_7 += edx.b
            *(eax_7 + 1) += (eax_7 + 1).b
            entry_ebx:1.b *= 2
            *arg3 -= (eax_7 + 1).b
            *arg3 += (eax_7 + 1).b
            *(eax_7 + 1) += (eax_7 + 1).b
            *(eax_7 + 1) += (eax_7 + 1).b
            *(eax_7 + 1) += (eax_7 + 1).b
            *(eax_7 + 1) = *(eax_7 + 1)
            *(eax_7 + 1) += (eax_7 + 1).b
            eax_7 = (eax_7 + 1) | *(eax_7 + 1)
        else
            uint16_t* esi_6 = __outsd(edx.w, *esi, esi, eflags)
            esi_7 = __outsb(edx.w, *esi_6, esi_6, eflags)
            
            if (not(z_3))
                if (s_1)
                    undefined
                
                jump(0x44a6a9)
        
        int32_t temp14 = *(arg6 + 0x77) | arg3
        *(arg6 + 0x77) = temp14
        __outsb(edx.w, *esi_7, esi_7, eflags)
        
        if (temp14 u>= 0)
            if (temp14 u< 0)
                jump(0x44a776)
            
            jump(0x44a715)
        
        *esp
        esp[1]
        void* ebx_1 = esp[4]
        esp[5]
        esp[6]
        esp[7]
        int32_t eflags_2
        int16_t temp0_6
        temp0_6, eflags_2 = __arpl_memw_gpr16(*(ebx_1 + 0x42), (esp[2]).w)
        *(ebx_1 + 0x42) = temp0_6
        
        if ((eax_7 | 0x72540b00) != 0)
            jump(&data_44a7d4:2)
        
        jump(0x44a762)
    
    esi = __outsb(edx.w, *(gsbase + esi), esi, eflags)
    
    if (temp3_1 == neg.b(edx.b))
        *arg6 += eax.b
        eax[(edx << 1) + 0x6f]
        edx.b |= eax[(edx << 1) + 0x6f]
        jump(0x44a5b1)
    
    *edx s>>= 0x42

goto label_44a5ed
