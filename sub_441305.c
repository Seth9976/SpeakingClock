// 函数: sub_441305
// 地址: 0x441305
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

bool c
char* eax = adc.d(arg1, *(arg1 * 2), c)
*eax += eax.b
*eax += eax.b
*eax += eax.b
char temp0 = eax:1.b
eax:1.b += arg2.b
bool c_1 = temp0 + arg2.b u< temp0
int32_t temp2 = *(eax * 2 - 0x1e)
int32_t eax_1 = adc.d(eax, temp2, c_1)
int32_t* eax_2 = adc.d(eax_1, *(eax_1 * 2 - 0x50), 
    adc.d(eax, temp2, c_1) u< eax || (c_1 && adc.d(eax, temp2, c_1) == eax))
*eax_2 += eax_2
int32_t entry_ebx
eax_2.b += entry_ebx:1.b
void* eax_3 = eax_2 ^ 0x3ac00045
*(arg5 + arg6 + 0x33fc0040) += entry_ebx:1.b
eax_3:1.b += eax_3.b
arg5[(arg3 << 2) + 0x45] += (arg2 + 2):1.b
*(eax_3 + 1) += (eax_3 + 1).b
*(&__return_addr + arg6) += entry_ebx.b
*(eax_3 + 2 + arg4 - 0x6053ffbc) += (arg2 + 2):1.b
*(eax_3 - 0x6d) += (arg2 + 2):1.b
*arg6 += arg3.b
arg6[(entry_ebx << 2) + 0x45] += (arg2 + 2):1.b
void* eax_5
eax_5:1.b = (eax_3 + 2):1.b + entry_ebx:1.b
int32_t var_4 = 0x45
*(eax_5 + 0x6a) += (arg3 + 1):1.b
char temp3 = eax_5.b
char temp4 = eax_5.b
eax_5.b *= 2

if (temp3 != neg.b(temp4))
    *arg6 = *arg5
    
    if (temp3 != neg.b(temp4))
        undefined
    
    jump(sub_441383+0x20)

eax_5.b += entry_ebx.b
*(arg2 + 2)
int32_t eflags
int32_t eflags_1
char temp0_1
char temp1_1
temp0_1, temp1_1, eflags_1 = __aaa(eax_5.b, eax_5:1.b, eflags)
eax_5.b = temp0_1
eax_5:1.b = temp1_1
eax_5.b += eax_5:1.b
eax_5.b = sbb.b(eax_5.b, 0x28, eax_5.b u< *(arg2 + 3))
*(eax_5 - 0x57ffba78) += entry_ebx.b
*((arg3 + 1) * 5 + 0x45) += eax_5:1.b
char temp6 = *(eax_5 - 0x2fffba98)
*(eax_5 - 0x2fffba98) += entry_ebx:1.b

if (not(add_overflow(temp6, entry_ebx:1.b)))
    jump(sub_441383+0x45)

int80_t x87_r0
return sub_441383(eax_5, arg2 + 3, arg3 + 1, arg4 + 3, arg5, arg6, x87_r0) __tailcall
