// 函数: sub_49e2b9
// 地址: 0x49e2b9
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

char* eax
void* entry_ebx
eax:1.b = (arg1 - 1):1.b + entry_ebx.b
eax:1.b += eax.b
eax.b += arg2:1.b
int32_t eflags
int32_t eflags_4 = __cli(__sti(__cli(__cli(eflags))))
*eax += eax:1.b
int32_t eflags_5 = __sti(eflags_4)
eax[0xfffffffb] += arg2.b
*(entry_ebx + (arg5 << 3) - 0x45bffb7) += eax.b
*eax += eax.b
char temp1 = *0x6f6f4354
*0x6f6f4354 += arg3 - 8
uint8_t* edi
uint8_t temp0
temp0, edi = __insb(arg5, arg2, eflags_5)
*edi = temp0
void* const* var_4 = &__return_addr

if (temp1 + arg3 - 8 u>= temp1)
    if (temp1 + arg3 - 8 s>= 0)
        jump(sub_49e320+0x12)
    
    jump(&data_49e2de[0xb])

*eax += eax.b
*eax += eax.b
*eax += eax.b
*eax = *eax
eax[0x49080003] += eax.b
int32_t eflags_6
int16_t temp0_1
temp0_1, eflags_6 = __arpl_memw_gpr16(*(edi + 0x6e), arg4.w)
*(edi + 0x6e) = temp0_1
*(entry_ebx + 0x74)
char* eax_1
int32_t ecx_8
int32_t edx
eax_1, edx, ecx_8 = 0x5948e36c()
*ecx_8
*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 = *eax_1
*eax_1 += eax_1.b
eax_1.b = eax_1.b
eax_1.b |= *(entry_ebx + 0x79)
int32_t eflags_7
int16_t temp0_2
temp0_2, eflags_7 = __arpl_memw_gpr16(*(arg4 + 0x49), arg4.w)
*(arg4 + 0x49) = temp0_2
int32_t eflags_8
int16_t temp0_3
temp0_3, eflags_8 = __arpl_memw_gpr16(*(edi + 0x6e), arg4.w)
*(edi + 0x6e) = temp0_3

if (eax_1.b u< 0)
    return sub_49e389(eax_1, edx) __tailcall

*eax_1 += eax_1.b
undefined
