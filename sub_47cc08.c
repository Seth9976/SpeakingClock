// 函数: sub_47cc08
// 地址: 0x47cc08
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

arg1.b |= *arg1
*arg1 += arg1.b
arg1:1.b = 0xbb
arg1[0x4ac1] += arg3:1.b
*arg1 += arg1.b
arg1[0x2c004abb] += (arg2 - 1):1.b
*(arg2 - 1) = ror.b(*(arg2 - 1), 0)
*arg1 += arg1.b
int32_t entry_ebx
*(entry_ebx + (arg4 << 2) - 0x4047ffb6) += arg3:1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg1[0xe8004abb] += arg3:1.b
*(arg2 - 2) = ror.b(*(arg2 - 2), 0)
*arg1 += arg1.b
*(entry_ebx + (arg4 << 2) - 0x3e23ffb6) -= 0x45
*arg1 += arg1.b
*arg1 += arg1.b
arg1[0x94004abb] -= 0x45
int32_t ecx
int16_t es
ecx, es = __les_gprz_memp(*(arg2 - 3))
*arg1 += arg1.b
char temp1 = *arg1
*arg1 += arg1.b
bool p = unimplemented  {add byte [eax], al}
bool a = unimplemented  {add byte [eax], al}
bool d
int32_t var_4 = (add_overflow(temp1, arg1.b) ? 1 : 0) << 0xb | (d ? 1 : 0) << 0xa
    | (temp1 + arg1.b s< 0 ? 1 : 0) << 7 | (temp1 == neg.b(arg1.b) ? 1 : 0) << 6 | (a ? 1 : 0) << 4
    | (p ? 1 : 0) << 2 | (temp1 + arg1.b u< temp1 ? 1 : 0)
*arg1 += arg1.b
*arg1 += arg1.b
arg1[0xe8004abb] += 0x4a
return arg1
