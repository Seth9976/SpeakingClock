// 函数: sub_46a870
// 地址: 0x46a870
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
arg1[0x80000000] += arg1.b
void* entry_ebx
int32_t* eax_1 = (arg1 & *arg1) | *(entry_ebx + 0x6f)
int32_t eflags
uint16_t* esi = __outsb(arg2.w, *arg5, arg5, eflags)
void* esp

if (eax_1 u< 0)
    if (eax_1 u>= 0)
        *(esi + 0x74)
        arg3.b += entry_ebx.b
        *eax_1 += eax_1
        jump(*(arg2 + (arg6 << 3) + 0x45))
    
    eax_1 += *eax_1
    *eax_1 += eax_1.b
    char* es
    char temp1_1 = *(es + esi)
    *(es + esi) += arg3.b
    bool c_1 = temp1_1 + arg3.b u< temp1_1
    arg6.w = __return_addr:1.w
    esi.w = __return_addr:3.w
    arg4.w = arg8
    void arg_9
    void* esp_1
    esp_1.w = &arg_9
    entry_ebx.w = *esp_1
    arg2.w = *(esp_1 + 2)
    arg3.w = *(esp_1 + 4)
    eax_1.w = *(esp_1 + 6)
    esp = esp_1 + 8
    
    if (&__return_addr != 0xffffffff)
        goto label_46a960
    
    if (&__return_addr == 0xffffffff)
        eax_1.b = sbb.b(eax_1.b, 0x45, c_1)
        *arg4 += entry_ebx.b
        entry_ebx:1.b *= 2
        TEB* fsbase
        *(fsbase + eax_1) += eax_1.b
        *arg3 += 1
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 += eax_1.b
        *eax_1 = *eax_1
        *eax_1 += eax_1.b
        *eax_1 -= eax_1
        *(arg2 + (esi << 1) + 0x61) |= eax_1.b
    label_46a960:
        uint16_t* esi_6 = __outsd(arg2.w, *esi, esi, eflags)
        char* gsbase
        *(gsbase + eax_1) += arg2.b
        *(eax_1 + 1) += arg2.b
        arg2:1.b += entry_ebx:1.b
        *(esp - 4) = 0xd4fe0000
        *(eax_1 + 1) += (eax_1 + 1).b
        *(eax_1 + 1) += (eax_1 + 1).b
        *arg3 = *arg3
        *(eax_1 + 1) += (eax_1 + 1).b
        *(esp - 4)
        __outsb(arg2.w, *esi_6, esi_6, eflags)
        *(esp - 2)
        uint16_t* esi_8 = *(esp + 2)
        void* ebp_3 = *(esp + 6)
        int16_t ebx_1 = (*(esp + 0xe)).w
        int32_t edx = *(esp + 0x12)
        char* ecx = *(esp + 0x16)
        char* eax_3 = *(esp + 0x1a)
        __bound_gprv_mema32(ebp_3, *(ebp_3 + 0x64))
        *eax_3 += edx.b
        *ecx += ebx_1.b
        ebx_1:1.b *= 2
        void* eax_4
        eax_4.b = (&eax_3[1]).b + 0x79
        *ecx += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 += eax_4.b
        *eax_4 = *eax_4
        *eax_4 += eax_4.b
        void* eax_5 = eax_4 - *eax_4
        char temp3 = edx.b
        edx.b |= *(eax_5 + 0x61)
        bool z = (temp3 | *(eax_5 + 0x61)) == 0
        __outsb(edx.w, *esi_8, esi_8, eflags)
        
        if (not(z))
            jump(0x46a9a7)
        
        *(esp + 0x1a) = esp + 0x1e
        *eax_5 = adc.b(*eax_5, eax_5.b, false)
        *eax_5 += eax_5.b
        undefined
    
    uint16_t* esi_1 = __outsd(arg2.w, *esi, esi, eflags)
    __outsb(arg2.w, *esi_1, esi_1, eflags)

uint16_t* esi_3 = *(arg6 + (arg4 << 1) + 0x72) * &data_401000
*arg3
entry_ebx:1.b *= 2
eax_1.b = 0xe3
*arg3 -= 0x1d
*eax_1 -= 0x1d
*eax_1 -= 0x1d
*eax_1 -= 0x1d
*eax_1 = *eax_1
*eax_1 -= 0x1d
int32_t eflags_1
char temp0
temp0, eflags_1 = __daa(0xe3, eflags)
eax_1.b = temp0
*eax_1 += arg3.b
__outsd(arg2.w, *esi_3, esi_3, eflags_1)
int32_t eflags_2
int16_t temp0_1
temp0_1, eflags_2 = __arpl_memw_gpr16(*(entry_ebx + 0x53), (&arg4[1]).w)
*(entry_ebx + 0x53) = temp0_1
int32_t esi_5 = *(arg4 - 0x3b) * 0x8f00451c
*eax_1 += eax_1.b
*(arg6 + 0x1ff0000) -= 1
*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 += eax_1.b
*eax_1 = *eax_1
*eax_1 += eax_1.b
*eax_1 -= eax_1.b
*(arg2 + (esi_5 << 1) + 0x61) |= eax_1.b
*(esp + 1)
*eax_1 += eax_1.b
jump(*(eax_1 * 2))
