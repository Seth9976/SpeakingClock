// 函数: sub_43f028
// 地址: 0x43f028
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
char temp1 = *arg1
*arg1 += arg1.b
bool o = add_overflow(temp1, arg1.b)
void* entry_ebx

if (o)
    if (o)
        int32_t eax_18 = sbb.d(&arg1[1], 0xd8f60134, temp1 + arg1.b u< temp1)
        bool c_3 = unimplemented  {sbb eax, 0xd8f60134}
        return sbb.d(eax_18, eax_18, c_3)
    
    entry_ebx += 1
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    *arg1 += arg1.b
    arg1[0xfffffff0] += arg2:1.b

char* ebx = entry_ebx + 1
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
*arg1 += arg1.b
arg2[0x100043f0] += arg2.b
*arg1 += arg1.b
char temp2 = arg1.b
arg1.b += ebx.b
*arg1 = adc.b(*arg1, arg1.b, temp2 + ebx.b u< temp2)
arg1.b = 0x3e
*(arg5 + arg6 + 0x3ec00040) += ebx:1.b
void* eax_1
eax_1:1.b = (&arg1[2]):1.b + (&arg1[2]).b
*(eax_1 + 0x403f) += ebx:1.b
*(&__return_addr + arg6) += ebx.b
*(eax_1 + 0x3e) += ebx.b
void* result = eax_1 + 3
*arg5 += arg3.b
*result += result.b
*result += result.b
*ebx += result.b
*result += result.b
*(result + arg2 + 0x40040) += ebx:1.b
*result += result.b
*result += result.b
*(result + arg2 + 0xc0040) += ebx:1.b
char temp3 = *result
*result += result.b
bool c_2 = temp3 + result.b u< temp3
bool z = temp3 == neg.b(result.b)
int16_t cs
*0x800400c = zx.d(cs)
*0x8004008 = 0x800400c
*0x8004004 = result
TEB* esp = 0x8004004

if (not(c_2))
    int32_t eflags
    int32_t esi = __outsb(arg2.w, *arg5, arg5, eflags)
    
    if (not(z))
        TEB* fsbase
        
        if (not(c_2))
            if (z || c_2)
                *arg2 += arg3:1.b
                *0x8004000 = ebx
                *0x8003ffc = esi
                *0x8003ff8 = arg4
                *0x8003ff4 = j_sub_40443c
                *0x8003ff0 = fsbase->NtTib.ExceptionList
                fsbase->NtTib.ExceptionList = 0x8003ff0
                sub_404d80(arg3, arg3)
                int32_t eax_12
                int32_t ecx_2
                eax_12, ecx_2 = sub_404fb0(*(result + 8), *(arg4 - 4))
                int32_t temp5_1 = *(result + 0xc)
                
                if (temp5_1 != 0)
                    sub_404d80(ecx_2, *(arg4 + 8))
                    sub_404fb0(*(result + 0xc), *(arg4 - 8))
                
                if (temp5_1 == 0 || temp5_1 == 0)
                    eax_12.b = 1
                
                *0x8003ff8
                fsbase->NtTib.ExceptionList = *0x8003ff0
                *0x8003ff8 = sub_43f17e
                return sub_404bac(arg4 - 8, 2)
            
            int32_t eflags_1
            int16_t temp0_1
            temp0_1, eflags_1 = __arpl_memw_gpr16(*(arg4 - 0x73), 0x4004)
            *(arg4 - 0x73) = temp0_1
            *(arg4 - 0x75) += arg2.b
            void* eax_4
            eax_4.b = __in_al_dx(arg2.w, eflags_1)
            *0x8004000 = ebx
            *0x8003ffc = esi
            *0x8003ff8 = arg6
            esp = 0x8003ff8
            
            if (arg2.b != 0)
                esp = 0x8003fe8
                eax_4 = sub_403fcc(arg3, arg2)
            
            ebx = arg2
            arg6 = eax_4
            arg3 = sub_404d80(sub_404d80(sub_403c38(arg3, 0), arg3), *(arg4 + 0xc))
            arg2 = *(arg4 + 8)
        
        sub_404d80(arg3, arg2)
        
        if (ebx.b != 0)
            sub_404024(arg6)
            fsbase->NtTib.ExceptionList = esp->NtTib.ExceptionList
            esp = &esp->NtTib.
        
        result = arg6
        esp->NtTib
        esp->NtTib
        (&esp->NtTib.StackBase - 4)->NtTib
        esp = &(&esp->NtTib.StackBase)[2]
    
    esp->NtTib
    esp = &esp->NtTib.StackBase

&esp->NtTib.StackBase
return result
