// 函数: sub_48cb08
// 地址: 0x48cb08
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

uint16_t* entry_ebx
*(arg1 - 1) += entry_ebx.b
*(arg1 - 1) += (arg1 - 1).b
void arg_48
char* eax
int32_t ecx
char* ecx_1
uint16_t* edx
eax, edx, ecx_1 = (*(&arg_48 + (ecx << 3)))()
*ecx_1 += eax.b
*eax += eax.b
*eax += eax.b
char temp1 = *eax
*eax += eax.b
*eax = adc.b(*eax, 0, temp1 + eax.b u< temp1)
*eax += eax.b
*eax = &eax[*eax]
char temp2 = eax.b
eax.b |= *(entry_ebx + 0x6f)
bool z = (temp2 | *(entry_ebx + 0x6f)) == 0
int32_t eflags
uint8_t* edi
uint8_t temp0
temp0, edi = __insb(arg3, edx.w, eflags)
*edi = temp0
uint16_t* esi = __outsd(edx.w, *arg2, arg2, eflags)
uint16_t* esi_1 = __outsd(edx.w, *esi, esi, eflags)

if (z)
    if (z)
        if (eax u>= 0x909390bd)
            jump("DGradie")
        
        return sub_48cb07() __tailcall
    
    undefined

*eax = adc.b(*eax, eax.b, false)

while (true)
    *eax
    char temp5_1 = entry_ebx:1.b
    char temp6_1 = entry_ebx:1.b
    entry_ebx:1.b *= 2
    
    if (temp5_1 + temp6_1 s< 0 == add_overflow(temp5_1, temp6_1))
        break
    
    *eax = adc.b(*eax, eax.b, temp5_1 + temp6_1 u< temp5_1)
    *eax -= eax.b
    void* esp
    *(esp - 4) = 0x10048cc
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax = *eax
    *eax += eax.b
    char temp4_1 = eax.b
    eax.b = eax.b
    int16_t cs
    *(esp - 8) = zx.d(cs)
    *(esp - 0xc) = eax
    *(esp - 8)
    *(esp - 4)
    *(esp + 4)
    int32_t edx_1 = *(esp + 8)
    *(esp + 0xc)
    int32_t result = *(esp + 0x10)
    uint8_t* edi_3
    uint8_t temp0_2
    temp0_2, edi_3 = __insb(*(esp - 0xc), edx_1.w, eflags)
    *edi_3 = temp0_2
    
    if (temp4_1 == 0)
        *(esp + 0x14)
        *(esp + 0x18)
        *(esp + 0x1c)
        return result
    
    *(esp + 0x10) = edx_1
    int32_t edi_4 = *(esp + 0x10)
    esi_1 = *(esp + 0x14)
    *(esp + 0x18)
    entry_ebx = *(esp + 0x20)
    edx = *(esp + 0x24)
    ecx_1 = *(esp + 0x28)
    eax = *(esp + 0x2c)
    esp += 0x30
    uint8_t* edi_5
    uint8_t temp0_3
    temp0_3, edi_5 = __insb(edi_4, edx.w, eflags)
    *edi_5 = temp0_3
    edi = *(edx + 0x65) * &data_401000

*ecx_1 += (eax - 1).b
*(eax - 1) += (eax - 1).b
*(eax - 1) += (eax - 1).b
*(eax - 1) += (eax - 1).b
*ecx_1 = *ecx_1
*(eax - 1) += (eax - 1).b
uint16_t* esi_5 = __outsd(edx.w, *esi_1, esi_1, eflags)
uint16_t* esi_6 = __outsd(edx.w, *esi_5, esi_5, eflags)
uint8_t* edi_6
uint8_t temp0_4
temp0_4, edi_6 = __insb(edi, edx.w, eflags)
*edi_6 = temp0_4
__outsd(edx.w, *esi_6, esi_6, eflags)

if (eax - 1 u>= 0x88abf700)
    jump(sub_48cc2c+2)

jump(0x48cbbb)
