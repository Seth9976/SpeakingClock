// 函数: sub_43869e
// 地址: 0x43869e
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

char* edx = arg2 + 1
char* entry_ebx
*entry_ebx += edx:1.b
char temp1 = arg1:1.b
char temp2 = arg1:1.b
int32_t ebx
ebx:1.b = arg1:1.b * 2
bool c = temp1 + temp2 u< temp1
char* eax
int32_t* esp
int32_t ebp_4

if (temp1 + temp2 s< 0)
    arg6 = __return_addr
    arg5 = arg7
    ebp_4 = arg8
    ebx = arg9
    edx = arg10
    arg3 = arg11
    eax = arg12
    void arg_20
    esp = &arg_20
    goto label_438721

eax:1.b = entry_ebx:1.b + entry_ebx.b
int32_t eflags
char* gsbase
bool c_2

if (entry_ebx:1.b + entry_ebx.b s>= 0)
    int32_t ebp_3 = arg4 + 2
    *eax += eax.b
    
    while (true)
        *eax += eax.b
        *eax = *eax
        char temp8_1 = eax[0x43050016]
        eax[0x43050016] += eax.b
        
        if (temp8_1 == neg.b(eax.b))
            *(gsbase + eax) += edx.b
            goto label_438770
        
        eax ^= *(eax + (arg5 << 2) + 0x14)
        ebp_4 = ebp_3 + 1
        *arg5 += ebx:1.b
        ebx:1.b *= 2
        ebx:1.b *= 2
        *eax = &eax[*eax]
        *eax += eax.b
        *eax += eax.b
        eax[0xfffffff4] += eax.b
        *esp
        char temp16_1 = *edx
        *edx += arg3.b
        c = temp16_1 + arg3.b u< temp16_1
        esp += 3
        
        if (c)
            *eax = &eax[*eax]
            break
        
    label_438721:
        int32_t temp5_1 = ebx
        ebx += 1
        
        if (temp5_1 != 0xffffffff)
            if (esp - 1 s< 0)
                breakpoint
            
            char temp10 = eax:1.b
            eax:1.b += ebx.b
            int16_t cs
            
            if (temp10 + ebx.b s< 0)
                *eax = &eax[*eax]
                *eax += eax.b
                *eax += eax.b
                char temp12 = eax[1]
                eax[1] += eax.b
                bool c_7 = temp12 + eax.b u< temp12
                char* eax_3 = sbb.d(eax, 0x61500b00, c_7)
                bool c_8 = unimplemented  {sbb eax, 0x61500b00}
                
                if (not(c_8))
                    __outsb(edx.w, *arg5, arg5, eflags)
                    
                    if (sbb.d(eax, 0x61500b00, c_7) == 0)
                        jump(0x43883d)
                    
                    jump("olor")
                
                *arg3 = *arg3
                *eax_3 += eax_3.b
                char temp17 = *eax_3 & eax_3.b
                *eax_3 = temp17
                *(esp - 5) = zx.d(cs)
                *(esp - 9) = eax_3
                *(esp - 9)
                *(esp - 5)
                *(esp - 1)
                *(esp + 7)
                *(esp + 0xb)
                *(esp + 0xf)
                *(esp + 0x13)
                
                if (temp17 u< 0)
                    undefined
                
                jump("ntShowHint")
            
            *eax += eax.b
            *eax += eax.b
            *eax = *eax
            char temp14 = eax[0x4604001b]
            eax[0x4604001b] += eax.b
            uint16_t* esi_3 = __outsd(edx.w, *arg5, arg5, eflags)
            int32_t esi_4 = __outsb(edx.w, *esi_3, esi_3, eflags)
            *eax = adc.b(*eax, eax.b, temp14 + eax.b u< temp14)
            *(esp - 5) = eax
            *(esp - 9) = arg3
            *(esp - 0xd) = edx
            *(esp - 0x11) = ebx
            *(esp - 0x15) = esp - 0x11
            *(esp - 0x19) = ebp_4
            *(esp - 0x1d) = esi_4
            *(esp - 0x21) = arg6
            *eax += eax.b
            *(esp - 0x25) = *eax
            *eax = &eax[*eax]
            *eax += eax.b
            *eax += eax.b
            char temp18 = eax[1]
            eax[1] += eax.b
            eax.b = sbb.b(eax.b, 0, temp18 + eax.b u< temp18)
            bool c_6 = unimplemented  {sbb al, 0x0}
            *(esp - 0x29) = zx.d(cs)
            *(esp - 0x2d) = eax
            *(esp - 0x2d)
            *(esp - 0x29)
            *(esp - 0x25)
            *(esp - 0x1d)
            *(esp - 0x19)
            *(esp - 0x15)
            *(esp - 0x11)
            
            if (c_6)
                jump(0x438833)
            
            jump("ntBiDiMode")
        
        if (not(c))
            goto label_438796
        
        if (not(c))
            eax.b = sbb.b(eax.b, 0x45, c)
            *(arg6 - 0x70010000) += arg3.b
            *eax += eax.b
            *arg3 += 1
            *eax += eax.b
            *eax += eax.b
            *eax += eax.b
            *eax = *eax
            char temp15_1 = *eax
            *eax += eax.b
            c_2 = temp15_1 + eax.b u< temp15_1
            goto label_438740
        
        ebp_3 = ebp_4 + 1
        eax[0x45fa] += arg3.b
else
    *eax += eax.b
    *eax += eax.b
    *0x14ff0000 = *0x14ff0000
    char* temp6_1 = eax
    eax = &eax[0x6f6c6f43]
    
    if (temp6_1 u< 0x909390bd)
        int16_t ds
        uint32_t var_4 = zx.d(ds)
        *(eax * 2) += edx:1.b
        undefined
    
    *eax += eax.b
    *eax = *eax
    char temp9_1 = eax[0x430b0015]
    eax[0x430b0015] += eax.b
    c_2 = temp9_1 + eax.b u< temp9_1
    uint16_t* esi = __outsd(edx.w, *arg5, arg5, eflags)
    arg5 = __outsb(edx.w, *esi, esi, eflags)
    
    if (c_2)
        if (not(c_2))
            *(arg5 + 0x74)
            arg3.b += ebx.b
            *eax = &eax[*eax]
            jump(*(edx + (arg6 << 3) + 0x45))
        
    label_438740:
        *eax = sbb.b(*eax, eax.b, c_2)
        edx[(arg5 << 1) + 0x61] |= eax.b
        *esp
        *eax += eax.b
        jump(*(eax * 2))
    
    ebx:1.b *= 2
    TEB* fsbase
    *(fsbase + eax) += eax.b
    *arg3 += 1
    *eax += eax.b
    *eax += eax.b
    *eax += eax.b
    *eax = *eax
    char temp11_1 = *eax
    *eax += eax.b
    *eax = sbb.d(*eax, eax, temp11_1 + eax.b u< temp11_1)
    edx[(arg5 << 1) + 0x61] |= eax.b
    arg5 = __outsd(edx.w, *arg5, arg5, eflags)
    *(gsbase + eax) += edx.b
label_438770:
    eax = &eax[1]
    *eax += edx.b
    edx:1.b += ebx:1.b
    *(esp - 4) = 0xd4fe0000
    esp -= 4
    *eax += eax.b
    *eax += eax.b
    *arg3 = *arg3
*eax += eax.b
*esp
__outsb(edx.w, *arg5, arg5, eflags)
*(esp + 2)
*(esp + 6)
void* ebp_6 = *(esp + 0xa)
ebx = *(esp + 0x12)
*(esp + 0x16)
int16_t ecx = (*(esp + 0x1a)).w
char* eax_1 = *(esp + 0x1e)
__bound_gprv_mema32(ebp_6, *(ebp_6 + 0x64))
*eax_1 += ecx:1.b
label_438796:
ebx:1.b *= 2
breakpoint
