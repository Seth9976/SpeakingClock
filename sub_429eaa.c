// 函数: sub_429eaa
// 地址: 0x429eaa
// 来自: E:/torrent/Tools/Speaking Clock/spclock.exe.bndb

char temp1 = *arg1
*arg1 += arg3.b
void* const* var_4 = &__return_addr

if (temp1 + arg3.b u>= temp1)
    jump(0x429eb1)

int32_t eflags
char* eax = __in_oeax_dx((arg2 + 1).w, eflags)
void* entry_ebx
entry_ebx.b += entry_ebx:1.b
*0xdd00429f += eax.b
arg3:1.b += eax:1.b
*arg3 += eax.b
*eax += eax.b
char temp2 = *(entry_ebx + 0x7ab8cd12)
*(entry_ebx + 0x7ab8cd12) += eax:1.b
bool c_1 = temp2 + eax:1.b u< temp2
int32_t eflags_1
char temp0
char temp1_1
temp0, temp1_1, eflags_1 = __aam_immb(0x11, eax.b)
eax.b = temp0
eax:1.b = temp1_1
double* edx_4 = sbb.d(arg2 + 5, 0, c_1)
char temp3 = *(arg6 + 0x61)
*(arg6 + 0x61) = ror.b(*(arg6 + 0x61), 0xb2)
bool c_2 = unimplemented  {ror byte [edi+0x60], 0xb2}
bool p = unimplemented  {ror byte [edi+0x60], 0xb2}
bool a = unimplemented  {ror byte [edi+0x60], 0xb2}
*edx_4 = fconvert.d(arg7)
eax:1.b = (ror.b(temp3, 0xb2) s< 0 ? 1 : 0) << 7 | (ror.b(temp3, 0xb2) == 0 ? 1 : 0) << 6
    | (a ? 1 : 0) << 4 | (p ? 1 : 0) << 2 | (c_2 ? 1 : 0)
*eax += arg3:1.b
*eax += eax.b
*eax += eax.b
*eax += eax.b
*(entry_ebx + 0x429f94c0) += arg3.b
char temp4 = *arg5
*arg5 += eax:1.b
bool p_1 = unimplemented  {add byte [esi], ah}
bool a_1 = unimplemented  {add byte [esi], ah}
eax:1.b = (temp4 + eax:1.b s< 0 ? 1 : 0) << 7 | (temp4 == neg.b(eax:1.b) ? 1 : 0) << 6
    | (a_1 ? 1 : 0) << 4 | (p_1 ? 1 : 0) << 2 | (temp4 + eax:1.b u< temp4 ? 1 : 0)
*eax += eax.b
*eax += eax.b
*(arg6 + 1 + (entry_ebx << 2) - 0x602bffbe) += eax:1.b
*eax += eax.b
*eax += eax.b
*eax += eax.b
*eax += eax.b
char temp5 = arg5[0xc400429f]
arg5[0xc400429f] += (edx_4 + 3):1.b
bool p_2 = unimplemented  {add byte [esi-0x3bffbd61], dh}
bool a_2 = unimplemented  {add byte [esi-0x3bffbd61], dh}
eax:1.b = (temp5 + (edx_4 + 3):1.b s< 0 ? 1 : 0) << 7
    | (temp5 == neg.b((edx_4 + 3):1.b) ? 1 : 0) << 6 | (a_2 ? 1 : 0) << 4 | (p_2 ? 1 : 0) << 2
    | (temp5 + (edx_4 + 3):1.b u< temp5 ? 1 : 0)
*(eax * 2) += arg3:1.b
*eax += eax.b
eax.b = 0x78
eax[0xb000403e] += (edx_4 + 4):1.b
eax.b = 0xf0
void* eax_1
eax_1:1.b = (&eax[1]):1.b + (&eax[1]).b
*(eax_1 + 0x403f) += entry_ebx:1.b
*(&var_4 + arg6 + 1) += entry_ebx.b
*(arg4 + 0x42) += entry_ebx:1.b
*(arg4 - 0x1617ffbe) += (&arg3[1]):1.b
*(arg6 + 0x43) += (edx_4 + 5).b
*(eax_1 - 0x55) += (eax_1 + 2).b
*arg5 += (&arg3[2]).b
*(eax_1 + 2) += (eax_1 + 2).b
*(eax_1 + 2) += (eax_1 + 2).b
arg3[2] += (eax_1 + 2).b
*(eax_1 + 2) += (eax_1 + 2).b
void* eax_3
eax_3.b = (eax_1 + 2).b + entry_ebx:1.b
*(arg6 + 1) += entry_ebx.b
*(arg6 + 1) += (arg6 + 1).b
*(edx_4 + 6) += (arg6 + 1).b
char* ecx_1
ecx_1:1.b = (&arg3[2]):1.b + entry_ebx:1.b
undefined
